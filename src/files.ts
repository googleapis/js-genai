/**
 * @license
 * Copyright 2025 Google LLC
 * SPDX-License-Identifier: Apache-2.0
 */

// Code generated by the Google Gen AI SDK generator DO NOT EDIT.

import {ApiClient} from './_api_client';
import * as common from './_common';
import {BaseModule} from './_common';
import * as t from './_transformers';
import {PagedItem, Pager} from './pagers';
import * as types from './types';

export class Files extends BaseModule {
  constructor(private readonly apiClient: ApiClient) {
    super();
  }

  /**
   * Lists all current project files from the service.
   *
   * @param params - The parameters for the list request
   * @return The paginated results of the list of files
   *
   * @example
   * The following code prints the names of all files from the service, the
   * size of each page is 10.
   *
   * ```ts
   * const listResponse = await ai.files.list({config: {'pageSize': 10}});
   * for await (const file of listResponse) {
   *   console.log(file.name);
   * }
   * ```
   */
  list = async (
    params: types.ListFilesParameters = {},
  ): Promise<Pager<types.File>> => {
    return new Pager<types.File>(
      PagedItem.PAGED_ITEM_FILES,
      (x: types.ListFilesParameters) => this.listInternal(x),
      await this.listInternal(params),
      params,
    );
  };

  /**
   * Uploads a file asynchronously to the Gemini API.
   * This method is not available in Vertex AI.
   * Supported upload sources:
   * - Node.js: File path (string) or Blob object.
   * - Browser: Blob object (e.g., File).
   *
   * @remarks
   * The `mimeType` can be specified in the `config` parameter. If omitted:
   *  - For file path (string) inputs, the `mimeType` will be inferred from the
   *     file extension.
   *  - For Blob object inputs, the `mimeType` will be set to the Blob's `type`
   *     property.
   * Somex eamples for file extension to mimeType mapping:
   * .txt -> text/plain
   * .json -> application/json
   * .jpg  -> image/jpeg
   * .png -> image/png
   * .mp3 -> audio/mpeg
   * .mp4 -> video/mp4
   *
   * This section can contain multiple paragraphs and code examples.
   *
   * @param params - Optional parameters specified in the
   *        `common.UploadFileParameters` interface.
   *        Optional @see {@link common.UploadFileParameters}
   * @return A promise that resolves to a `types.File` object.
   * @throws An error if called on a Vertex AI client.
   * @throws An error if the `mimeType` is not provided and can not be inferred,
   * the `mimeType` can be provided in the `params.config` parameter.
   * @throws An error occurs if a suitable upload location cannot be established.
   *
   * @example
   * The following code uploads a file to Gemini API.
   *
   * ```ts
   * const file = await ai.files.upload({file: 'file.txt', config: {
   *   mimeType: 'text/plain',
   * }});
   * console.log(file.name);
   * ```
   */
  async upload(params: common.UploadFileParameters): Promise<types.File> {
    if (this.apiClient.isVertexAI()) {
      throw new Error(
        'Vertex AI does not support uploading files. You can share files through a GCS bucket.',
      );
    }

    return this.apiClient
      .uploadFile(params.file, params.config)
      .then((response) => {
        const file = fileFromMldev(this.apiClient, response);
        return file as types.File;
      });
  }

  private async listInternal(
    params: types.ListFilesParameters,
  ): Promise<types.ListFilesResponse> {
    let response: Promise<types.ListFilesResponse>;
    let path: string = '';
    let queryParams: Record<string, string> = {};
    if (this.apiClient.isVertexAI()) {
      throw new Error(
        'This method is only supported by the Gemini Developer API.',
      );
    } else {
      const body = listFilesParametersToMldev(this.apiClient, params);
      path = common.formatMap('files', body['_url'] as Record<string, unknown>);
      queryParams = body['_query'] as Record<string, string>;
      delete body['config'];
      delete body['_url'];
      delete body['_query'];

      response = this.apiClient
        .request({
          path: path,
          queryParams: queryParams,
          body: JSON.stringify(body),
          httpMethod: 'GET',
          httpOptions: params.config?.httpOptions,
        })
        .then((httpResponse) => {
          return httpResponse.json();
        }) as Promise<types.ListFilesResponse>;

      return response.then((apiResponse) => {
        const resp = listFilesResponseFromMldev(this.apiClient, apiResponse);
        const typedResp = new types.ListFilesResponse();
        Object.assign(typedResp, resp);
        return typedResp;
      });
    }
  }

  private async createInternal(
    params: types.CreateFileParameters,
  ): Promise<types.CreateFileResponse> {
    let response: Promise<types.CreateFileResponse>;
    let path: string = '';
    let queryParams: Record<string, string> = {};
    if (this.apiClient.isVertexAI()) {
      throw new Error(
        'This method is only supported by the Gemini Developer API.',
      );
    } else {
      const body = createFileParametersToMldev(this.apiClient, params);
      path = common.formatMap(
        'upload/v1beta/files',
        body['_url'] as Record<string, unknown>,
      );
      queryParams = body['_query'] as Record<string, string>;
      delete body['config'];
      delete body['_url'];
      delete body['_query'];

      response = this.apiClient
        .request({
          path: path,
          queryParams: queryParams,
          body: JSON.stringify(body),
          httpMethod: 'POST',
          httpOptions: params.config?.httpOptions,
        })
        .then((httpResponse) => {
          return httpResponse.json();
        }) as Promise<types.CreateFileResponse>;

      return response.then((apiResponse) => {
        const resp = createFileResponseFromMldev(this.apiClient, apiResponse);
        const typedResp = new types.CreateFileResponse();
        Object.assign(typedResp, resp);
        return typedResp;
      });
    }
  }

  /**
   * Retrieves the file information from the service.
   *
   * @param params - The parameters for the get request
   * @return The Promise that resolves to the types.File object requested.
   *
   * @example
   * ```ts
   * const config: GetFileParameters = {
   *   name: fileName,
   * };
   * file = await ai.files.get(config);
   * console.log(file.name);
   * ```
   */
  async get(params: types.GetFileParameters): Promise<types.File> {
    let response: Promise<types.File>;
    let path: string = '';
    let queryParams: Record<string, string> = {};
    if (this.apiClient.isVertexAI()) {
      throw new Error(
        'This method is only supported by the Gemini Developer API.',
      );
    } else {
      const body = getFileParametersToMldev(this.apiClient, params);
      path = common.formatMap(
        'files/{file}',
        body['_url'] as Record<string, unknown>,
      );
      queryParams = body['_query'] as Record<string, string>;
      delete body['config'];
      delete body['_url'];
      delete body['_query'];

      response = this.apiClient
        .request({
          path: path,
          queryParams: queryParams,
          body: JSON.stringify(body),
          httpMethod: 'GET',
          httpOptions: params.config?.httpOptions,
        })
        .then((httpResponse) => {
          return httpResponse.json();
        }) as Promise<types.File>;

      return response.then((apiResponse) => {
        const resp = fileFromMldev(this.apiClient, apiResponse);

        return resp as types.File;
      });
    }
  }
}

function listFilesConfigToMldev(
  apiClient: ApiClient,
  fromObject: types.ListFilesConfig,
  parentObject: Record<string, unknown>,
): Record<string, unknown> {
  const toObject: Record<string, unknown> = {};

  const fromPageSize = common.getValueByPath(fromObject, ['pageSize']);
  if (parentObject !== undefined && fromPageSize != null) {
    common.setValueByPath(parentObject, ['_query', 'pageSize'], fromPageSize);
  }

  const fromPageToken = common.getValueByPath(fromObject, ['pageToken']);
  if (parentObject !== undefined && fromPageToken != null) {
    common.setValueByPath(parentObject, ['_query', 'pageToken'], fromPageToken);
  }

  return toObject;
}

function listFilesConfigToVertex(
  apiClient: ApiClient,
  fromObject: types.ListFilesConfig,
  parentObject: Record<string, unknown>,
): Record<string, unknown> {
  const toObject: Record<string, unknown> = {};

  const fromPageSize = common.getValueByPath(fromObject, ['pageSize']);
  if (parentObject !== undefined && fromPageSize != null) {
    common.setValueByPath(parentObject, ['_query', 'pageSize'], fromPageSize);
  }

  const fromPageToken = common.getValueByPath(fromObject, ['pageToken']);
  if (parentObject !== undefined && fromPageToken != null) {
    common.setValueByPath(parentObject, ['_query', 'pageToken'], fromPageToken);
  }

  return toObject;
}

function listFilesParametersToMldev(
  apiClient: ApiClient,
  fromObject: types.ListFilesParameters,
): Record<string, unknown> {
  const toObject: Record<string, unknown> = {};

  const fromConfig = common.getValueByPath(fromObject, ['config']);
  if (fromConfig != null) {
    common.setValueByPath(
      toObject,
      ['config'],
      listFilesConfigToMldev(apiClient, fromConfig, toObject),
    );
  }

  return toObject;
}

function listFilesParametersToVertex(
  apiClient: ApiClient,
  fromObject: types.ListFilesParameters,
): Record<string, unknown> {
  const toObject: Record<string, unknown> = {};

  if (common.getValueByPath(fromObject, ['config']) !== undefined) {
    throw new Error('config parameter is not supported in Vertex AI.');
  }

  return toObject;
}

function fileStatusToMldev(
  apiClient: ApiClient,
  fromObject: types.FileStatus,
): Record<string, unknown> {
  const toObject: Record<string, unknown> = {};

  const fromDetails = common.getValueByPath(fromObject, ['details']);
  if (fromDetails != null) {
    common.setValueByPath(toObject, ['details'], fromDetails);
  }

  const fromMessage = common.getValueByPath(fromObject, ['message']);
  if (fromMessage != null) {
    common.setValueByPath(toObject, ['message'], fromMessage);
  }

  const fromCode = common.getValueByPath(fromObject, ['code']);
  if (fromCode != null) {
    common.setValueByPath(toObject, ['code'], fromCode);
  }

  return toObject;
}

function fileStatusToVertex(
  apiClient: ApiClient,
  fromObject: types.FileStatus,
): Record<string, unknown> {
  const toObject: Record<string, unknown> = {};

  if (common.getValueByPath(fromObject, ['details']) !== undefined) {
    throw new Error('details parameter is not supported in Vertex AI.');
  }

  if (common.getValueByPath(fromObject, ['message']) !== undefined) {
    throw new Error('message parameter is not supported in Vertex AI.');
  }

  if (common.getValueByPath(fromObject, ['code']) !== undefined) {
    throw new Error('code parameter is not supported in Vertex AI.');
  }

  return toObject;
}

function fileToMldev(
  apiClient: ApiClient,
  fromObject: types.File,
): Record<string, unknown> {
  const toObject: Record<string, unknown> = {};

  const fromName = common.getValueByPath(fromObject, ['name']);
  if (fromName != null) {
    common.setValueByPath(toObject, ['name'], fromName);
  }

  const fromDisplayName = common.getValueByPath(fromObject, ['displayName']);
  if (fromDisplayName != null) {
    common.setValueByPath(toObject, ['displayName'], fromDisplayName);
  }

  const fromMimeType = common.getValueByPath(fromObject, ['mimeType']);
  if (fromMimeType != null) {
    common.setValueByPath(toObject, ['mimeType'], fromMimeType);
  }

  const fromSizeBytes = common.getValueByPath(fromObject, ['sizeBytes']);
  if (fromSizeBytes != null) {
    common.setValueByPath(toObject, ['sizeBytes'], fromSizeBytes);
  }

  const fromCreateTime = common.getValueByPath(fromObject, ['createTime']);
  if (fromCreateTime != null) {
    common.setValueByPath(toObject, ['createTime'], fromCreateTime);
  }

  const fromExpirationTime = common.getValueByPath(fromObject, [
    'expirationTime',
  ]);
  if (fromExpirationTime != null) {
    common.setValueByPath(toObject, ['expirationTime'], fromExpirationTime);
  }

  const fromUpdateTime = common.getValueByPath(fromObject, ['updateTime']);
  if (fromUpdateTime != null) {
    common.setValueByPath(toObject, ['updateTime'], fromUpdateTime);
  }

  const fromSha256Hash = common.getValueByPath(fromObject, ['sha256Hash']);
  if (fromSha256Hash != null) {
    common.setValueByPath(toObject, ['sha256Hash'], fromSha256Hash);
  }

  const fromUri = common.getValueByPath(fromObject, ['uri']);
  if (fromUri != null) {
    common.setValueByPath(toObject, ['uri'], fromUri);
  }

  const fromDownloadUri = common.getValueByPath(fromObject, ['downloadUri']);
  if (fromDownloadUri != null) {
    common.setValueByPath(toObject, ['downloadUri'], fromDownloadUri);
  }

  const fromState = common.getValueByPath(fromObject, ['state']);
  if (fromState != null) {
    common.setValueByPath(toObject, ['state'], fromState);
  }

  const fromSource = common.getValueByPath(fromObject, ['source']);
  if (fromSource != null) {
    common.setValueByPath(toObject, ['source'], fromSource);
  }

  const fromVideoMetadata = common.getValueByPath(fromObject, [
    'videoMetadata',
  ]);
  if (fromVideoMetadata != null) {
    common.setValueByPath(toObject, ['videoMetadata'], fromVideoMetadata);
  }

  const fromError = common.getValueByPath(fromObject, ['error']);
  if (fromError != null) {
    common.setValueByPath(
      toObject,
      ['error'],
      fileStatusToMldev(apiClient, fromError),
    );
  }

  return toObject;
}

function fileToVertex(
  apiClient: ApiClient,
  fromObject: types.File,
): Record<string, unknown> {
  const toObject: Record<string, unknown> = {};

  if (common.getValueByPath(fromObject, ['name']) !== undefined) {
    throw new Error('name parameter is not supported in Vertex AI.');
  }

  if (common.getValueByPath(fromObject, ['displayName']) !== undefined) {
    throw new Error('displayName parameter is not supported in Vertex AI.');
  }

  if (common.getValueByPath(fromObject, ['mimeType']) !== undefined) {
    throw new Error('mimeType parameter is not supported in Vertex AI.');
  }

  if (common.getValueByPath(fromObject, ['sizeBytes']) !== undefined) {
    throw new Error('sizeBytes parameter is not supported in Vertex AI.');
  }

  if (common.getValueByPath(fromObject, ['createTime']) !== undefined) {
    throw new Error('createTime parameter is not supported in Vertex AI.');
  }

  if (common.getValueByPath(fromObject, ['expirationTime']) !== undefined) {
    throw new Error('expirationTime parameter is not supported in Vertex AI.');
  }

  if (common.getValueByPath(fromObject, ['updateTime']) !== undefined) {
    throw new Error('updateTime parameter is not supported in Vertex AI.');
  }

  if (common.getValueByPath(fromObject, ['sha256Hash']) !== undefined) {
    throw new Error('sha256Hash parameter is not supported in Vertex AI.');
  }

  if (common.getValueByPath(fromObject, ['uri']) !== undefined) {
    throw new Error('uri parameter is not supported in Vertex AI.');
  }

  if (common.getValueByPath(fromObject, ['downloadUri']) !== undefined) {
    throw new Error('downloadUri parameter is not supported in Vertex AI.');
  }

  if (common.getValueByPath(fromObject, ['state']) !== undefined) {
    throw new Error('state parameter is not supported in Vertex AI.');
  }

  if (common.getValueByPath(fromObject, ['source']) !== undefined) {
    throw new Error('source parameter is not supported in Vertex AI.');
  }

  if (common.getValueByPath(fromObject, ['videoMetadata']) !== undefined) {
    throw new Error('videoMetadata parameter is not supported in Vertex AI.');
  }

  if (common.getValueByPath(fromObject, ['error']) !== undefined) {
    throw new Error('error parameter is not supported in Vertex AI.');
  }

  return toObject;
}

function createFileParametersToMldev(
  apiClient: ApiClient,
  fromObject: types.CreateFileParameters,
): Record<string, unknown> {
  const toObject: Record<string, unknown> = {};

  const fromFile = common.getValueByPath(fromObject, ['file']);
  if (fromFile != null) {
    common.setValueByPath(toObject, ['file'], fileToMldev(apiClient, fromFile));
  }

  const fromConfig = common.getValueByPath(fromObject, ['config']);
  if (fromConfig != null) {
    common.setValueByPath(toObject, ['config'], fromConfig);
  }

  return toObject;
}

function createFileParametersToVertex(
  apiClient: ApiClient,
  fromObject: types.CreateFileParameters,
): Record<string, unknown> {
  const toObject: Record<string, unknown> = {};

  if (common.getValueByPath(fromObject, ['file']) !== undefined) {
    throw new Error('file parameter is not supported in Vertex AI.');
  }

  if (common.getValueByPath(fromObject, ['config']) !== undefined) {
    throw new Error('config parameter is not supported in Vertex AI.');
  }

  return toObject;
}

function getFileParametersToMldev(
  apiClient: ApiClient,
  fromObject: types.GetFileParameters,
): Record<string, unknown> {
  const toObject: Record<string, unknown> = {};

  const fromName = common.getValueByPath(fromObject, ['name']);
  if (fromName != null) {
    common.setValueByPath(
      toObject,
      ['_url', 'file'],
      t.tFileName(apiClient, fromName),
    );
  }

  const fromConfig = common.getValueByPath(fromObject, ['config']);
  if (fromConfig != null) {
    common.setValueByPath(toObject, ['config'], fromConfig);
  }

  return toObject;
}

function getFileParametersToVertex(
  apiClient: ApiClient,
  fromObject: types.GetFileParameters,
): Record<string, unknown> {
  const toObject: Record<string, unknown> = {};

  if (common.getValueByPath(fromObject, ['name']) !== undefined) {
    throw new Error('name parameter is not supported in Vertex AI.');
  }

  if (common.getValueByPath(fromObject, ['config']) !== undefined) {
    throw new Error('config parameter is not supported in Vertex AI.');
  }

  return toObject;
}

function fileStatusFromMldev(
  apiClient: ApiClient,
  fromObject: types.FileStatus,
): Record<string, unknown> {
  const toObject: Record<string, unknown> = {};

  const fromDetails = common.getValueByPath(fromObject, ['details']);
  if (fromDetails != null) {
    common.setValueByPath(toObject, ['details'], fromDetails);
  }

  const fromMessage = common.getValueByPath(fromObject, ['message']);
  if (fromMessage != null) {
    common.setValueByPath(toObject, ['message'], fromMessage);
  }

  const fromCode = common.getValueByPath(fromObject, ['code']);
  if (fromCode != null) {
    common.setValueByPath(toObject, ['code'], fromCode);
  }

  return toObject;
}

function fileStatusFromVertex(): Record<string, unknown> {
  const toObject: Record<string, unknown> = {};

  return toObject;
}

function fileFromMldev(
  apiClient: ApiClient,
  fromObject: types.File,
): Record<string, unknown> {
  const toObject: Record<string, unknown> = {};

  const fromName = common.getValueByPath(fromObject, ['name']);
  if (fromName != null) {
    common.setValueByPath(toObject, ['name'], fromName);
  }

  const fromDisplayName = common.getValueByPath(fromObject, ['displayName']);
  if (fromDisplayName != null) {
    common.setValueByPath(toObject, ['displayName'], fromDisplayName);
  }

  const fromMimeType = common.getValueByPath(fromObject, ['mimeType']);
  if (fromMimeType != null) {
    common.setValueByPath(toObject, ['mimeType'], fromMimeType);
  }

  const fromSizeBytes = common.getValueByPath(fromObject, ['sizeBytes']);
  if (fromSizeBytes != null) {
    common.setValueByPath(toObject, ['sizeBytes'], Number(fromSizeBytes));
  }

  const fromCreateTime = common.getValueByPath(fromObject, ['createTime']);
  if (fromCreateTime != null) {
    common.setValueByPath(toObject, ['createTime'], fromCreateTime);
  }

  const fromExpirationTime = common.getValueByPath(fromObject, [
    'expirationTime',
  ]);
  if (fromExpirationTime != null) {
    common.setValueByPath(toObject, ['expirationTime'], fromExpirationTime);
  }

  const fromUpdateTime = common.getValueByPath(fromObject, ['updateTime']);
  if (fromUpdateTime != null) {
    common.setValueByPath(toObject, ['updateTime'], fromUpdateTime);
  }

  const fromSha256Hash = common.getValueByPath(fromObject, ['sha256Hash']);
  if (fromSha256Hash != null) {
    common.setValueByPath(toObject, ['sha256Hash'], fromSha256Hash);
  }

  const fromUri = common.getValueByPath(fromObject, ['uri']);
  if (fromUri != null) {
    common.setValueByPath(toObject, ['uri'], fromUri);
  }

  const fromDownloadUri = common.getValueByPath(fromObject, ['downloadUri']);
  if (fromDownloadUri != null) {
    common.setValueByPath(toObject, ['downloadUri'], fromDownloadUri);
  }

  const fromState = common.getValueByPath(fromObject, ['state']);
  if (fromState != null) {
    common.setValueByPath(toObject, ['state'], fromState);
  }

  const fromSource = common.getValueByPath(fromObject, ['source']);
  if (fromSource != null) {
    common.setValueByPath(toObject, ['source'], fromSource);
  }

  const fromVideoMetadata = common.getValueByPath(fromObject, [
    'videoMetadata',
  ]);
  if (fromVideoMetadata != null) {
    common.setValueByPath(toObject, ['videoMetadata'], fromVideoMetadata);
  }

  const fromError = common.getValueByPath(fromObject, ['error']);
  if (fromError != null) {
    common.setValueByPath(
      toObject,
      ['error'],
      fileStatusFromMldev(apiClient, fromError),
    );
  }

  return toObject;
}

function fileFromVertex(): Record<string, unknown> {
  const toObject: Record<string, unknown> = {};

  return toObject;
}

function listFilesResponseFromMldev(
  apiClient: ApiClient,
  fromObject: types.ListFilesResponse,
): Record<string, unknown> {
  const toObject: Record<string, unknown> = {};

  const fromNextPageToken = common.getValueByPath(fromObject, [
    'nextPageToken',
  ]);
  if (fromNextPageToken != null) {
    common.setValueByPath(toObject, ['nextPageToken'], fromNextPageToken);
  }

  const fromFiles = common.getValueByPath(fromObject, ['files']);
  if (fromFiles != null) {
    if (Array.isArray(fromFiles)) {
      common.setValueByPath(
        toObject,
        ['files'],
        fromFiles.map((item) => {
          return fileFromMldev(apiClient, item);
        }),
      );
    } else {
      common.setValueByPath(toObject, ['files'], fromFiles);
    }
  }

  return toObject;
}

function listFilesResponseFromVertex(): Record<string, unknown> {
  const toObject: Record<string, unknown> = {};

  return toObject;
}

function createFileResponseFromMldev(
  apiClient: ApiClient,
  fromObject: types.CreateFileResponse,
): Record<string, unknown> {
  const toObject: Record<string, unknown> = {};

  const fromHttpHeaders = common.getValueByPath(fromObject, ['httpHeaders']);
  if (fromHttpHeaders != null) {
    common.setValueByPath(toObject, ['httpHeaders'], fromHttpHeaders);
  }

  return toObject;
}

function createFileResponseFromVertex(
  apiClient: ApiClient,
  fromObject: types.CreateFileResponse,
): Record<string, unknown> {
  const toObject: Record<string, unknown> = {};

  const fromHttpHeaders = common.getValueByPath(fromObject, ['httpHeaders']);
  if (fromHttpHeaders != null) {
    common.setValueByPath(toObject, ['httpHeaders'], fromHttpHeaders);
  }

  return toObject;
}
