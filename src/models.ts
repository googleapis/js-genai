/**
 * @license
 * Copyright 2025 Google LLC
 * SPDX-License-Identifier: Apache-2.0
 */

// Code generated by the Google Gen AI SDK generator DO NOT EDIT.

import {ApiClient} from './_api_client';
import * as common from './_common';
import {BaseModule} from './_common';
import * as t from './_transformers';
import * as types from './types';

export class Models extends BaseModule {
  constructor(private readonly apiClient: ApiClient) {
    super();
  }

  /**
   * Makes an API request to generate content with a given model.
   *
   * For the `model` parameter, supported formats for Vertex AI API include:
   * - The Gemini model ID, for example: 'gemini-2.0-flash'
   * - The full resource name starts with 'projects/', for example:
   *  'projects/my-project-id/locations/us-central1/publishers/google/models/gemini-2.0-flash'
   * - The partial resource name with 'publishers/', for example:
   *  'publishers/google/models/gemini-2.0-flash' or
   *  'publishers/meta/models/llama-3.1-405b-instruct-maas'
   * - `/` separated publisher and model name, for example:
   * 'google/gemini-2.0-flash' or 'meta/llama-3.1-405b-instruct-maas'
   *
   * For the `model` parameter, supported formats for Gemini API include:
   * - The Gemini model ID, for example: 'gemini-2.0-flash'
   * - The model name starts with 'models/', for example:
   *  'models/gemini-2.0-flash'
   * - For tuned models, the model name starts with 'tunedModels/',
   * for example:
   * 'tunedModels/1234567890123456789'
   *
   * Some models support multimodal input and output.
   *
   * @param params - The parameters for generating content.
   * @return The response from generating content.
   *
   * @example
   * ```ts
   * const response = await ai.models.generateContent({
   *   model: 'gemini-2.0-flash',
   *   contents: 'why is the sky blue?',
   *   config: {
   *     candidateCount: 2,
   *   }
   * });
   * console.log(response);
   * ```
   */
  generateContent = async (
    params: types.GenerateContentParameters,
  ): Promise<types.GenerateContentResponse> => {
    return await this.generateContentInternal(params);
  };

  /**
   * Makes an API request to generate content with a given model and yields the
   * response in chunks.
   *
   * For the `model` parameter, supported formats for Vertex AI API include:
   * - The Gemini model ID, for example: 'gemini-2.0-flash'
   * - The full resource name starts with 'projects/', for example:
   *  'projects/my-project-id/locations/us-central1/publishers/google/models/gemini-2.0-flash'
   * - The partial resource name with 'publishers/', for example:
   *  'publishers/google/models/gemini-2.0-flash' or
   *  'publishers/meta/models/llama-3.1-405b-instruct-maas'
   * - `/` separated publisher and model name, for example:
   * 'google/gemini-2.0-flash' or 'meta/llama-3.1-405b-instruct-maas'
   *
   * For the `model` parameter, supported formats for Gemini API include:
   * - The Gemini model ID, for example: 'gemini-2.0-flash'
   * - The model name starts with 'models/', for example:
   *  'models/gemini-2.0-flash'
   * - For tuned models, the model name starts with 'tunedModels/',
   * for example:
   *  'tunedModels/1234567890123456789'
   *
   * Some models support multimodal input and output.
   *
   * @param params - The parameters for generating content with streaming response.
   * @return The response from generating content.
   *
   * @example
   * ```ts
   * const response = await ai.models.generateContentStream({
   *   model: 'gemini-2.0-flash',
   *   contents: 'why is the sky blue?',
   *   config: {
   *     maxOutputTokens: 200,
   *   }
   * });
   * for await (const chunk of response) {
   *   console.log(chunk);
   * }
   * ```
   */
  generateContentStream = async (
    params: types.GenerateContentParameters,
  ): Promise<AsyncGenerator<types.GenerateContentResponse>> => {
    return await this.generateContentStreamInternal(params);
  };

  private async generateContentInternal(
    params: types.GenerateContentParameters,
  ): Promise<types.GenerateContentResponse> {
    let response: Promise<types.GenerateContentResponse>;
    let path: string = '';
    let queryParams: Record<string, string> = {};
    if (this.apiClient.isVertexAI()) {
      const body = generateContentParametersToVertex(this.apiClient, params);
      path = common.formatMap(
        '{model}:generateContent',
        body['_url'] as Record<string, unknown>,
      );
      queryParams = body['_query'] as Record<string, string>;
      delete body['config'];
      delete body['_url'];
      delete body['_query'];

      response = this.apiClient
        .request({
          path: path,
          queryParams: queryParams,
          body: JSON.stringify(body),
          httpMethod: 'POST',
          httpOptions: params.config?.httpOptions,
        })
        .then((httpResponse) => {
          return httpResponse.json();
        }) as Promise<types.GenerateContentResponse>;

      return response.then((apiResponse) => {
        const resp = generateContentResponseFromVertex(
          this.apiClient,
          apiResponse,
        );
        const typedResp = new types.GenerateContentResponse();
        Object.assign(typedResp, resp);
        return typedResp;
      });
    } else {
      const body = generateContentParametersToMldev(this.apiClient, params);
      path = common.formatMap(
        '{model}:generateContent',
        body['_url'] as Record<string, unknown>,
      );
      queryParams = body['_query'] as Record<string, string>;
      delete body['config'];
      delete body['_url'];
      delete body['_query'];

      response = this.apiClient
        .request({
          path: path,
          queryParams: queryParams,
          body: JSON.stringify(body),
          httpMethod: 'POST',
          httpOptions: params.config?.httpOptions,
        })
        .then((httpResponse) => {
          return httpResponse.json();
        }) as Promise<types.GenerateContentResponse>;

      return response.then((apiResponse) => {
        const resp = generateContentResponseFromMldev(
          this.apiClient,
          apiResponse,
        );
        const typedResp = new types.GenerateContentResponse();
        Object.assign(typedResp, resp);
        return typedResp;
      });
    }
  }

  private async generateContentStreamInternal(
    params: types.GenerateContentParameters,
  ): Promise<AsyncGenerator<types.GenerateContentResponse>> {
    let response: Promise<AsyncGenerator<types.GenerateContentResponse>>;
    let path: string = '';
    let queryParams: Record<string, string> = {};
    if (this.apiClient.isVertexAI()) {
      const body = generateContentParametersToVertex(this.apiClient, params);
      path = common.formatMap(
        '{model}:streamGenerateContent?alt=sse',
        body['_url'] as Record<string, unknown>,
      );
      queryParams = body['_query'] as Record<string, string>;
      delete body['config'];
      delete body['_url'];
      delete body['_query'];

      const apiClient = this.apiClient;
      response = apiClient.requestStream({
        path: path,
        queryParams: queryParams,
        body: JSON.stringify(body),
        httpMethod: 'POST',
        httpOptions: params.config?.httpOptions,
      }) as Promise<AsyncGenerator<types.GenerateContentResponse>>;

      return response.then(async function* (
        apiResponse: AsyncGenerator<types.GenerateContentResponse>,
      ) {
        for await (const chunk of apiResponse) {
          const resp = generateContentResponseFromVertex(apiClient, chunk);
          const typedResp = new types.GenerateContentResponse();
          Object.assign(typedResp, resp);
          yield typedResp;
        }
      });
    } else {
      const body = generateContentParametersToMldev(this.apiClient, params);
      path = common.formatMap(
        '{model}:streamGenerateContent?alt=sse',
        body['_url'] as Record<string, unknown>,
      );
      queryParams = body['_query'] as Record<string, string>;
      delete body['config'];
      delete body['_url'];
      delete body['_query'];

      const apiClient = this.apiClient;
      response = apiClient.requestStream({
        path: path,
        queryParams: queryParams,
        body: JSON.stringify(body),
        httpMethod: 'POST',
        httpOptions: params.config?.httpOptions,
      }) as Promise<AsyncGenerator<types.GenerateContentResponse>>;

      return response.then(async function* (
        apiResponse: AsyncGenerator<types.GenerateContentResponse>,
      ) {
        for await (const chunk of apiResponse) {
          const resp = generateContentResponseFromMldev(apiClient, chunk);
          const typedResp = new types.GenerateContentResponse();
          Object.assign(typedResp, resp);
          yield typedResp;
        }
      });
    }
  }

  /**
   * Calculates embeddings for the given contents. Only text is supported.
   *
   * @param params - The parameters for embedding contents.
   * @return The response from the API.
   *
   * @example
   * ```ts
   * const response = await ai.models.embedContent({
   *  model: 'text-embedding-004',
   *  contents: [
   *    'What is your name?',
   *    'What is your favorite color?',
   *  ],
   *  config: {
   *    outputDimensionality: 64,
   *  },
   * });
   * console.log(response);
   * ```
   */
  async embedContent(
    params: types.EmbedContentParameters,
  ): Promise<types.EmbedContentResponse> {
    let response: Promise<types.EmbedContentResponse>;
    let path: string = '';
    let queryParams: Record<string, string> = {};
    if (this.apiClient.isVertexAI()) {
      const body = embedContentParametersToVertex(this.apiClient, params);
      path = common.formatMap(
        '{model}:predict',
        body['_url'] as Record<string, unknown>,
      );
      queryParams = body['_query'] as Record<string, string>;
      delete body['config'];
      delete body['_url'];
      delete body['_query'];

      response = this.apiClient
        .request({
          path: path,
          queryParams: queryParams,
          body: JSON.stringify(body),
          httpMethod: 'POST',
          httpOptions: params.config?.httpOptions,
        })
        .then((httpResponse) => {
          return httpResponse.json();
        }) as Promise<types.EmbedContentResponse>;

      return response.then((apiResponse) => {
        const resp = embedContentResponseFromVertex(
          this.apiClient,
          apiResponse,
        );
        const typedResp = new types.EmbedContentResponse();
        Object.assign(typedResp, resp);
        return typedResp;
      });
    } else {
      const body = embedContentParametersToMldev(this.apiClient, params);
      path = common.formatMap(
        '{model}:batchEmbedContents',
        body['_url'] as Record<string, unknown>,
      );
      queryParams = body['_query'] as Record<string, string>;
      delete body['config'];
      delete body['_url'];
      delete body['_query'];

      response = this.apiClient
        .request({
          path: path,
          queryParams: queryParams,
          body: JSON.stringify(body),
          httpMethod: 'POST',
          httpOptions: params.config?.httpOptions,
        })
        .then((httpResponse) => {
          return httpResponse.json();
        }) as Promise<types.EmbedContentResponse>;

      return response.then((apiResponse) => {
        const resp = embedContentResponseFromMldev(this.apiClient, apiResponse);
        const typedResp = new types.EmbedContentResponse();
        Object.assign(typedResp, resp);
        return typedResp;
      });
    }
  }

  /**
   * Generates an image based on a text description and configuration.
   *
   * @param params - The parameters for generating images.
   * @return The response from the API.
   *
   * @example
   * ```ts
   * const response = await ai.models.generateImages({
   *  model: 'imagen-3.0-generate-002',
   *  prompt: 'Robot holding a red skateboard',
   *  config: {
   *    numberOfImages: 1,
   *    includeRaiReason: true,
   *  },
   * });
   * console.log(response?.generatedImages?.[0]?.image?.imageBytes);
   * ```
   */
  async generateImages(
    params: types.GenerateImagesParameters,
  ): Promise<types.GenerateImagesResponse> {
    let response: Promise<types.GenerateImagesResponse>;
    let path: string = '';
    let queryParams: Record<string, string> = {};
    if (this.apiClient.isVertexAI()) {
      const body = generateImagesParametersToVertex(this.apiClient, params);
      path = common.formatMap(
        '{model}:predict',
        body['_url'] as Record<string, unknown>,
      );
      queryParams = body['_query'] as Record<string, string>;
      delete body['config'];
      delete body['_url'];
      delete body['_query'];

      response = this.apiClient
        .request({
          path: path,
          queryParams: queryParams,
          body: JSON.stringify(body),
          httpMethod: 'POST',
          httpOptions: params.config?.httpOptions,
        })
        .then((httpResponse) => {
          return httpResponse.json();
        }) as Promise<types.GenerateImagesResponse>;

      return response.then((apiResponse) => {
        const resp = generateImagesResponseFromVertex(
          this.apiClient,
          apiResponse,
        );
        const typedResp = new types.GenerateImagesResponse();
        Object.assign(typedResp, resp);
        return typedResp;
      });
    } else {
      const body = generateImagesParametersToMldev(this.apiClient, params);
      path = common.formatMap(
        '{model}:predict',
        body['_url'] as Record<string, unknown>,
      );
      queryParams = body['_query'] as Record<string, string>;
      delete body['config'];
      delete body['_url'];
      delete body['_query'];

      response = this.apiClient
        .request({
          path: path,
          queryParams: queryParams,
          body: JSON.stringify(body),
          httpMethod: 'POST',
          httpOptions: params.config?.httpOptions,
        })
        .then((httpResponse) => {
          return httpResponse.json();
        }) as Promise<types.GenerateImagesResponse>;

      return response.then((apiResponse) => {
        const resp = generateImagesResponseFromMldev(
          this.apiClient,
          apiResponse,
        );
        const typedResp = new types.GenerateImagesResponse();
        Object.assign(typedResp, resp);
        return typedResp;
      });
    }
  }

  /**
   * Counts the number of tokens in the given contents. Multimodal input is
   * supported for Gemini models.
   *
   * @param params - The parameters for counting tokens.
   * @return The response from the API.
   *
   * @example
   * ```ts
   * const response = await ai.models.countTokens({
   *  model: 'gemini-2.0-flash',
   *  contents: 'The quick brown fox jumps over the lazy dog.'
   * });
   * console.log(response);
   * ```
   */
  async countTokens(
    params: types.CountTokensParameters,
  ): Promise<types.CountTokensResponse> {
    let response: Promise<types.CountTokensResponse>;
    let path: string = '';
    let queryParams: Record<string, string> = {};
    if (this.apiClient.isVertexAI()) {
      const body = countTokensParametersToVertex(this.apiClient, params);
      path = common.formatMap(
        '{model}:countTokens',
        body['_url'] as Record<string, unknown>,
      );
      queryParams = body['_query'] as Record<string, string>;
      delete body['config'];
      delete body['_url'];
      delete body['_query'];

      response = this.apiClient
        .request({
          path: path,
          queryParams: queryParams,
          body: JSON.stringify(body),
          httpMethod: 'POST',
          httpOptions: params.config?.httpOptions,
        })
        .then((httpResponse) => {
          return httpResponse.json();
        }) as Promise<types.CountTokensResponse>;

      return response.then((apiResponse) => {
        const resp = countTokensResponseFromVertex(this.apiClient, apiResponse);
        const typedResp = new types.CountTokensResponse();
        Object.assign(typedResp, resp);
        return typedResp;
      });
    } else {
      const body = countTokensParametersToMldev(this.apiClient, params);
      path = common.formatMap(
        '{model}:countTokens',
        body['_url'] as Record<string, unknown>,
      );
      queryParams = body['_query'] as Record<string, string>;
      delete body['config'];
      delete body['_url'];
      delete body['_query'];

      response = this.apiClient
        .request({
          path: path,
          queryParams: queryParams,
          body: JSON.stringify(body),
          httpMethod: 'POST',
          httpOptions: params.config?.httpOptions,
        })
        .then((httpResponse) => {
          return httpResponse.json();
        }) as Promise<types.CountTokensResponse>;

      return response.then((apiResponse) => {
        const resp = countTokensResponseFromMldev(this.apiClient, apiResponse);
        const typedResp = new types.CountTokensResponse();
        Object.assign(typedResp, resp);
        return typedResp;
      });
    }
  }

  /**
   * Given a list of contents, returns a corresponding TokensInfo containing
   * the list of tokens and list of token ids.
   *
   * This method is not supported by the Gemini Developer API.
   *
   * @param params - The parameters for computing tokens.
   * @return The response from the API.
   *
   * @example
   * ```ts
   * const response = await ai.models.computeTokens({
   *  model: 'gemini-2.0-flash',
   *  contents: 'What is your name?'
   * });
   * console.log(response);
   * ```
   */
  async computeTokens(
    params: types.ComputeTokensParameters,
  ): Promise<types.ComputeTokensResponse> {
    let response: Promise<types.ComputeTokensResponse>;
    let path: string = '';
    let queryParams: Record<string, string> = {};
    if (this.apiClient.isVertexAI()) {
      const body = computeTokensParametersToVertex(this.apiClient, params);
      path = common.formatMap(
        '{model}:computeTokens',
        body['_url'] as Record<string, unknown>,
      );
      queryParams = body['_query'] as Record<string, string>;
      delete body['config'];
      delete body['_url'];
      delete body['_query'];

      response = this.apiClient
        .request({
          path: path,
          queryParams: queryParams,
          body: JSON.stringify(body),
          httpMethod: 'POST',
          httpOptions: params.config?.httpOptions,
        })
        .then((httpResponse) => {
          return httpResponse.json();
        }) as Promise<types.ComputeTokensResponse>;

      return response.then((apiResponse) => {
        const resp = computeTokensResponseFromVertex(
          this.apiClient,
          apiResponse,
        );
        const typedResp = new types.ComputeTokensResponse();
        Object.assign(typedResp, resp);
        return typedResp;
      });
    } else {
      throw new Error('This method is only supported by the Vertex AI.');
    }
  }
}

function partToMldev(
  apiClient: ApiClient,
  fromObject: types.Part,
): Record<string, unknown> {
  const toObject: Record<string, unknown> = {};

  if (common.getValueByPath(fromObject, ['videoMetadata']) !== undefined) {
    throw new Error('videoMetadata parameter is not supported in Gemini API.');
  }

  const fromThought = common.getValueByPath(fromObject, ['thought']);
  if (fromThought != null) {
    common.setValueByPath(toObject, ['thought'], fromThought);
  }

  const fromCodeExecutionResult = common.getValueByPath(fromObject, [
    'codeExecutionResult',
  ]);
  if (fromCodeExecutionResult != null) {
    common.setValueByPath(
      toObject,
      ['codeExecutionResult'],
      fromCodeExecutionResult,
    );
  }

  const fromExecutableCode = common.getValueByPath(fromObject, [
    'executableCode',
  ]);
  if (fromExecutableCode != null) {
    common.setValueByPath(toObject, ['executableCode'], fromExecutableCode);
  }

  const fromFileData = common.getValueByPath(fromObject, ['fileData']);
  if (fromFileData != null) {
    common.setValueByPath(toObject, ['fileData'], fromFileData);
  }

  const fromFunctionCall = common.getValueByPath(fromObject, ['functionCall']);
  if (fromFunctionCall != null) {
    common.setValueByPath(toObject, ['functionCall'], fromFunctionCall);
  }

  const fromFunctionResponse = common.getValueByPath(fromObject, [
    'functionResponse',
  ]);
  if (fromFunctionResponse != null) {
    common.setValueByPath(toObject, ['functionResponse'], fromFunctionResponse);
  }

  const fromInlineData = common.getValueByPath(fromObject, ['inlineData']);
  if (fromInlineData != null) {
    common.setValueByPath(toObject, ['inlineData'], fromInlineData);
  }

  const fromText = common.getValueByPath(fromObject, ['text']);
  if (fromText != null) {
    common.setValueByPath(toObject, ['text'], fromText);
  }

  return toObject;
}

function partToVertex(
  apiClient: ApiClient,
  fromObject: types.Part,
): Record<string, unknown> {
  const toObject: Record<string, unknown> = {};

  const fromVideoMetadata = common.getValueByPath(fromObject, [
    'videoMetadata',
  ]);
  if (fromVideoMetadata != null) {
    common.setValueByPath(toObject, ['videoMetadata'], fromVideoMetadata);
  }

  const fromThought = common.getValueByPath(fromObject, ['thought']);
  if (fromThought != null) {
    common.setValueByPath(toObject, ['thought'], fromThought);
  }

  const fromCodeExecutionResult = common.getValueByPath(fromObject, [
    'codeExecutionResult',
  ]);
  if (fromCodeExecutionResult != null) {
    common.setValueByPath(
      toObject,
      ['codeExecutionResult'],
      fromCodeExecutionResult,
    );
  }

  const fromExecutableCode = common.getValueByPath(fromObject, [
    'executableCode',
  ]);
  if (fromExecutableCode != null) {
    common.setValueByPath(toObject, ['executableCode'], fromExecutableCode);
  }

  const fromFileData = common.getValueByPath(fromObject, ['fileData']);
  if (fromFileData != null) {
    common.setValueByPath(toObject, ['fileData'], fromFileData);
  }

  const fromFunctionCall = common.getValueByPath(fromObject, ['functionCall']);
  if (fromFunctionCall != null) {
    common.setValueByPath(toObject, ['functionCall'], fromFunctionCall);
  }

  const fromFunctionResponse = common.getValueByPath(fromObject, [
    'functionResponse',
  ]);
  if (fromFunctionResponse != null) {
    common.setValueByPath(toObject, ['functionResponse'], fromFunctionResponse);
  }

  const fromInlineData = common.getValueByPath(fromObject, ['inlineData']);
  if (fromInlineData != null) {
    common.setValueByPath(toObject, ['inlineData'], fromInlineData);
  }

  const fromText = common.getValueByPath(fromObject, ['text']);
  if (fromText != null) {
    common.setValueByPath(toObject, ['text'], fromText);
  }

  return toObject;
}

/** @internal */
export function contentToMldev(
  apiClient: ApiClient,
  fromObject: types.Content,
): Record<string, unknown> {
  const toObject: Record<string, unknown> = {};

  const fromParts = common.getValueByPath(fromObject, ['parts']);
  if (fromParts != null) {
    if (Array.isArray(fromParts)) {
      common.setValueByPath(
        toObject,
        ['parts'],
        fromParts.map((item) => {
          return partToMldev(apiClient, item);
        }),
      );
    } else {
      common.setValueByPath(toObject, ['parts'], fromParts);
    }
  }

  const fromRole = common.getValueByPath(fromObject, ['role']);
  if (fromRole != null) {
    common.setValueByPath(toObject, ['role'], fromRole);
  }

  return toObject;
}

/** @internal */
export function contentToVertex(
  apiClient: ApiClient,
  fromObject: types.Content,
): Record<string, unknown> {
  const toObject: Record<string, unknown> = {};

  const fromParts = common.getValueByPath(fromObject, ['parts']);
  if (fromParts != null) {
    if (Array.isArray(fromParts)) {
      common.setValueByPath(
        toObject,
        ['parts'],
        fromParts.map((item) => {
          return partToVertex(apiClient, item);
        }),
      );
    } else {
      common.setValueByPath(toObject, ['parts'], fromParts);
    }
  }

  const fromRole = common.getValueByPath(fromObject, ['role']);
  if (fromRole != null) {
    common.setValueByPath(toObject, ['role'], fromRole);
  }

  return toObject;
}

function schemaToMldev(
  apiClient: ApiClient,
  fromObject: types.Schema,
): Record<string, unknown> {
  const toObject: Record<string, unknown> = {};

  if (common.getValueByPath(fromObject, ['example']) !== undefined) {
    throw new Error('example parameter is not supported in Gemini API.');
  }

  if (common.getValueByPath(fromObject, ['pattern']) !== undefined) {
    throw new Error('pattern parameter is not supported in Gemini API.');
  }

  if (common.getValueByPath(fromObject, ['default']) !== undefined) {
    throw new Error('default parameter is not supported in Gemini API.');
  }

  if (common.getValueByPath(fromObject, ['maxLength']) !== undefined) {
    throw new Error('maxLength parameter is not supported in Gemini API.');
  }

  if (common.getValueByPath(fromObject, ['title']) !== undefined) {
    throw new Error('title parameter is not supported in Gemini API.');
  }

  if (common.getValueByPath(fromObject, ['minLength']) !== undefined) {
    throw new Error('minLength parameter is not supported in Gemini API.');
  }

  if (common.getValueByPath(fromObject, ['minProperties']) !== undefined) {
    throw new Error('minProperties parameter is not supported in Gemini API.');
  }

  if (common.getValueByPath(fromObject, ['maxProperties']) !== undefined) {
    throw new Error('maxProperties parameter is not supported in Gemini API.');
  }

  const fromAnyOf = common.getValueByPath(fromObject, ['anyOf']);
  if (fromAnyOf != null) {
    common.setValueByPath(toObject, ['anyOf'], fromAnyOf);
  }

  const fromDescription = common.getValueByPath(fromObject, ['description']);
  if (fromDescription != null) {
    common.setValueByPath(toObject, ['description'], fromDescription);
  }

  const fromEnum = common.getValueByPath(fromObject, ['enum']);
  if (fromEnum != null) {
    common.setValueByPath(toObject, ['enum'], fromEnum);
  }

  const fromFormat = common.getValueByPath(fromObject, ['format']);
  if (fromFormat != null) {
    common.setValueByPath(toObject, ['format'], fromFormat);
  }

  const fromItems = common.getValueByPath(fromObject, ['items']);
  if (fromItems != null) {
    common.setValueByPath(toObject, ['items'], fromItems);
  }

  const fromMaxItems = common.getValueByPath(fromObject, ['maxItems']);
  if (fromMaxItems != null) {
    common.setValueByPath(toObject, ['maxItems'], fromMaxItems);
  }

  const fromMaximum = common.getValueByPath(fromObject, ['maximum']);
  if (fromMaximum != null) {
    common.setValueByPath(toObject, ['maximum'], fromMaximum);
  }

  const fromMinItems = common.getValueByPath(fromObject, ['minItems']);
  if (fromMinItems != null) {
    common.setValueByPath(toObject, ['minItems'], fromMinItems);
  }

  const fromMinimum = common.getValueByPath(fromObject, ['minimum']);
  if (fromMinimum != null) {
    common.setValueByPath(toObject, ['minimum'], fromMinimum);
  }

  const fromNullable = common.getValueByPath(fromObject, ['nullable']);
  if (fromNullable != null) {
    common.setValueByPath(toObject, ['nullable'], fromNullable);
  }

  const fromProperties = common.getValueByPath(fromObject, ['properties']);
  if (fromProperties != null) {
    common.setValueByPath(toObject, ['properties'], fromProperties);
  }

  const fromPropertyOrdering = common.getValueByPath(fromObject, [
    'propertyOrdering',
  ]);
  if (fromPropertyOrdering != null) {
    common.setValueByPath(toObject, ['propertyOrdering'], fromPropertyOrdering);
  }

  const fromRequired = common.getValueByPath(fromObject, ['required']);
  if (fromRequired != null) {
    common.setValueByPath(toObject, ['required'], fromRequired);
  }

  const fromType = common.getValueByPath(fromObject, ['type']);
  if (fromType != null) {
    common.setValueByPath(toObject, ['type'], fromType);
  }

  return toObject;
}

function schemaToVertex(
  apiClient: ApiClient,
  fromObject: types.Schema,
): Record<string, unknown> {
  const toObject: Record<string, unknown> = {};

  const fromExample = common.getValueByPath(fromObject, ['example']);
  if (fromExample != null) {
    common.setValueByPath(toObject, ['example'], fromExample);
  }

  const fromPattern = common.getValueByPath(fromObject, ['pattern']);
  if (fromPattern != null) {
    common.setValueByPath(toObject, ['pattern'], fromPattern);
  }

  const fromDefault = common.getValueByPath(fromObject, ['default']);
  if (fromDefault != null) {
    common.setValueByPath(toObject, ['default'], fromDefault);
  }

  const fromMaxLength = common.getValueByPath(fromObject, ['maxLength']);
  if (fromMaxLength != null) {
    common.setValueByPath(toObject, ['maxLength'], fromMaxLength);
  }

  const fromTitle = common.getValueByPath(fromObject, ['title']);
  if (fromTitle != null) {
    common.setValueByPath(toObject, ['title'], fromTitle);
  }

  const fromMinLength = common.getValueByPath(fromObject, ['minLength']);
  if (fromMinLength != null) {
    common.setValueByPath(toObject, ['minLength'], fromMinLength);
  }

  const fromMinProperties = common.getValueByPath(fromObject, [
    'minProperties',
  ]);
  if (fromMinProperties != null) {
    common.setValueByPath(toObject, ['minProperties'], fromMinProperties);
  }

  const fromMaxProperties = common.getValueByPath(fromObject, [
    'maxProperties',
  ]);
  if (fromMaxProperties != null) {
    common.setValueByPath(toObject, ['maxProperties'], fromMaxProperties);
  }

  const fromAnyOf = common.getValueByPath(fromObject, ['anyOf']);
  if (fromAnyOf != null) {
    common.setValueByPath(toObject, ['anyOf'], fromAnyOf);
  }

  const fromDescription = common.getValueByPath(fromObject, ['description']);
  if (fromDescription != null) {
    common.setValueByPath(toObject, ['description'], fromDescription);
  }

  const fromEnum = common.getValueByPath(fromObject, ['enum']);
  if (fromEnum != null) {
    common.setValueByPath(toObject, ['enum'], fromEnum);
  }

  const fromFormat = common.getValueByPath(fromObject, ['format']);
  if (fromFormat != null) {
    common.setValueByPath(toObject, ['format'], fromFormat);
  }

  const fromItems = common.getValueByPath(fromObject, ['items']);
  if (fromItems != null) {
    common.setValueByPath(toObject, ['items'], fromItems);
  }

  const fromMaxItems = common.getValueByPath(fromObject, ['maxItems']);
  if (fromMaxItems != null) {
    common.setValueByPath(toObject, ['maxItems'], fromMaxItems);
  }

  const fromMaximum = common.getValueByPath(fromObject, ['maximum']);
  if (fromMaximum != null) {
    common.setValueByPath(toObject, ['maximum'], fromMaximum);
  }

  const fromMinItems = common.getValueByPath(fromObject, ['minItems']);
  if (fromMinItems != null) {
    common.setValueByPath(toObject, ['minItems'], fromMinItems);
  }

  const fromMinimum = common.getValueByPath(fromObject, ['minimum']);
  if (fromMinimum != null) {
    common.setValueByPath(toObject, ['minimum'], fromMinimum);
  }

  const fromNullable = common.getValueByPath(fromObject, ['nullable']);
  if (fromNullable != null) {
    common.setValueByPath(toObject, ['nullable'], fromNullable);
  }

  const fromProperties = common.getValueByPath(fromObject, ['properties']);
  if (fromProperties != null) {
    common.setValueByPath(toObject, ['properties'], fromProperties);
  }

  const fromPropertyOrdering = common.getValueByPath(fromObject, [
    'propertyOrdering',
  ]);
  if (fromPropertyOrdering != null) {
    common.setValueByPath(toObject, ['propertyOrdering'], fromPropertyOrdering);
  }

  const fromRequired = common.getValueByPath(fromObject, ['required']);
  if (fromRequired != null) {
    common.setValueByPath(toObject, ['required'], fromRequired);
  }

  const fromType = common.getValueByPath(fromObject, ['type']);
  if (fromType != null) {
    common.setValueByPath(toObject, ['type'], fromType);
  }

  return toObject;
}

function safetySettingToMldev(
  apiClient: ApiClient,
  fromObject: types.SafetySetting,
): Record<string, unknown> {
  const toObject: Record<string, unknown> = {};

  if (common.getValueByPath(fromObject, ['method']) !== undefined) {
    throw new Error('method parameter is not supported in Gemini API.');
  }

  const fromCategory = common.getValueByPath(fromObject, ['category']);
  if (fromCategory != null) {
    common.setValueByPath(toObject, ['category'], fromCategory);
  }

  const fromThreshold = common.getValueByPath(fromObject, ['threshold']);
  if (fromThreshold != null) {
    common.setValueByPath(toObject, ['threshold'], fromThreshold);
  }

  return toObject;
}

function safetySettingToVertex(
  apiClient: ApiClient,
  fromObject: types.SafetySetting,
): Record<string, unknown> {
  const toObject: Record<string, unknown> = {};

  const fromMethod = common.getValueByPath(fromObject, ['method']);
  if (fromMethod != null) {
    common.setValueByPath(toObject, ['method'], fromMethod);
  }

  const fromCategory = common.getValueByPath(fromObject, ['category']);
  if (fromCategory != null) {
    common.setValueByPath(toObject, ['category'], fromCategory);
  }

  const fromThreshold = common.getValueByPath(fromObject, ['threshold']);
  if (fromThreshold != null) {
    common.setValueByPath(toObject, ['threshold'], fromThreshold);
  }

  return toObject;
}

function functionDeclarationToMldev(
  apiClient: ApiClient,
  fromObject: types.FunctionDeclaration,
): Record<string, unknown> {
  const toObject: Record<string, unknown> = {};

  if (common.getValueByPath(fromObject, ['response']) !== undefined) {
    throw new Error('response parameter is not supported in Gemini API.');
  }

  const fromDescription = common.getValueByPath(fromObject, ['description']);
  if (fromDescription != null) {
    common.setValueByPath(toObject, ['description'], fromDescription);
  }

  const fromName = common.getValueByPath(fromObject, ['name']);
  if (fromName != null) {
    common.setValueByPath(toObject, ['name'], fromName);
  }

  const fromParameters = common.getValueByPath(fromObject, ['parameters']);
  if (fromParameters != null) {
    common.setValueByPath(toObject, ['parameters'], fromParameters);
  }

  return toObject;
}

function functionDeclarationToVertex(
  apiClient: ApiClient,
  fromObject: types.FunctionDeclaration,
): Record<string, unknown> {
  const toObject: Record<string, unknown> = {};

  const fromResponse = common.getValueByPath(fromObject, ['response']);
  if (fromResponse != null) {
    common.setValueByPath(
      toObject,
      ['response'],
      schemaToVertex(apiClient, fromResponse),
    );
  }

  const fromDescription = common.getValueByPath(fromObject, ['description']);
  if (fromDescription != null) {
    common.setValueByPath(toObject, ['description'], fromDescription);
  }

  const fromName = common.getValueByPath(fromObject, ['name']);
  if (fromName != null) {
    common.setValueByPath(toObject, ['name'], fromName);
  }

  const fromParameters = common.getValueByPath(fromObject, ['parameters']);
  if (fromParameters != null) {
    common.setValueByPath(toObject, ['parameters'], fromParameters);
  }

  return toObject;
}

function googleSearchToMldev(): Record<string, unknown> {
  const toObject: Record<string, unknown> = {};

  return toObject;
}

function googleSearchToVertex(): Record<string, unknown> {
  const toObject: Record<string, unknown> = {};

  return toObject;
}

function dynamicRetrievalConfigToMldev(
  apiClient: ApiClient,
  fromObject: types.DynamicRetrievalConfig,
): Record<string, unknown> {
  const toObject: Record<string, unknown> = {};

  const fromMode = common.getValueByPath(fromObject, ['mode']);
  if (fromMode != null) {
    common.setValueByPath(toObject, ['mode'], fromMode);
  }

  const fromDynamicThreshold = common.getValueByPath(fromObject, [
    'dynamicThreshold',
  ]);
  if (fromDynamicThreshold != null) {
    common.setValueByPath(toObject, ['dynamicThreshold'], fromDynamicThreshold);
  }

  return toObject;
}

function dynamicRetrievalConfigToVertex(
  apiClient: ApiClient,
  fromObject: types.DynamicRetrievalConfig,
): Record<string, unknown> {
  const toObject: Record<string, unknown> = {};

  const fromMode = common.getValueByPath(fromObject, ['mode']);
  if (fromMode != null) {
    common.setValueByPath(toObject, ['mode'], fromMode);
  }

  const fromDynamicThreshold = common.getValueByPath(fromObject, [
    'dynamicThreshold',
  ]);
  if (fromDynamicThreshold != null) {
    common.setValueByPath(toObject, ['dynamicThreshold'], fromDynamicThreshold);
  }

  return toObject;
}

function googleSearchRetrievalToMldev(
  apiClient: ApiClient,
  fromObject: types.GoogleSearchRetrieval,
): Record<string, unknown> {
  const toObject: Record<string, unknown> = {};

  const fromDynamicRetrievalConfig = common.getValueByPath(fromObject, [
    'dynamicRetrievalConfig',
  ]);
  if (fromDynamicRetrievalConfig != null) {
    common.setValueByPath(
      toObject,
      ['dynamicRetrievalConfig'],
      dynamicRetrievalConfigToMldev(apiClient, fromDynamicRetrievalConfig),
    );
  }

  return toObject;
}

function googleSearchRetrievalToVertex(
  apiClient: ApiClient,
  fromObject: types.GoogleSearchRetrieval,
): Record<string, unknown> {
  const toObject: Record<string, unknown> = {};

  const fromDynamicRetrievalConfig = common.getValueByPath(fromObject, [
    'dynamicRetrievalConfig',
  ]);
  if (fromDynamicRetrievalConfig != null) {
    common.setValueByPath(
      toObject,
      ['dynamicRetrievalConfig'],
      dynamicRetrievalConfigToVertex(apiClient, fromDynamicRetrievalConfig),
    );
  }

  return toObject;
}

/** @internal */
export function toolToMldev(
  apiClient: ApiClient,
  fromObject: types.Tool,
): Record<string, unknown> {
  const toObject: Record<string, unknown> = {};

  const fromFunctionDeclarations = common.getValueByPath(fromObject, [
    'functionDeclarations',
  ]);
  if (fromFunctionDeclarations != null) {
    if (Array.isArray(fromFunctionDeclarations)) {
      common.setValueByPath(
        toObject,
        ['functionDeclarations'],
        fromFunctionDeclarations.map((item) => {
          return functionDeclarationToMldev(apiClient, item);
        }),
      );
    } else {
      common.setValueByPath(
        toObject,
        ['functionDeclarations'],
        fromFunctionDeclarations,
      );
    }
  }

  if (common.getValueByPath(fromObject, ['retrieval']) !== undefined) {
    throw new Error('retrieval parameter is not supported in Gemini API.');
  }

  const fromGoogleSearch = common.getValueByPath(fromObject, ['googleSearch']);
  if (fromGoogleSearch != null) {
    common.setValueByPath(toObject, ['googleSearch'], googleSearchToMldev());
  }

  const fromGoogleSearchRetrieval = common.getValueByPath(fromObject, [
    'googleSearchRetrieval',
  ]);
  if (fromGoogleSearchRetrieval != null) {
    common.setValueByPath(
      toObject,
      ['googleSearchRetrieval'],
      googleSearchRetrievalToMldev(apiClient, fromGoogleSearchRetrieval),
    );
  }

  const fromCodeExecution = common.getValueByPath(fromObject, [
    'codeExecution',
  ]);
  if (fromCodeExecution != null) {
    common.setValueByPath(toObject, ['codeExecution'], fromCodeExecution);
  }

  return toObject;
}

/** @internal */
export function toolToVertex(
  apiClient: ApiClient,
  fromObject: types.Tool,
): Record<string, unknown> {
  const toObject: Record<string, unknown> = {};

  const fromFunctionDeclarations = common.getValueByPath(fromObject, [
    'functionDeclarations',
  ]);
  if (fromFunctionDeclarations != null) {
    if (Array.isArray(fromFunctionDeclarations)) {
      common.setValueByPath(
        toObject,
        ['functionDeclarations'],
        fromFunctionDeclarations.map((item) => {
          return functionDeclarationToVertex(apiClient, item);
        }),
      );
    } else {
      common.setValueByPath(
        toObject,
        ['functionDeclarations'],
        fromFunctionDeclarations,
      );
    }
  }

  const fromRetrieval = common.getValueByPath(fromObject, ['retrieval']);
  if (fromRetrieval != null) {
    common.setValueByPath(toObject, ['retrieval'], fromRetrieval);
  }

  const fromGoogleSearch = common.getValueByPath(fromObject, ['googleSearch']);
  if (fromGoogleSearch != null) {
    common.setValueByPath(toObject, ['googleSearch'], googleSearchToVertex());
  }

  const fromGoogleSearchRetrieval = common.getValueByPath(fromObject, [
    'googleSearchRetrieval',
  ]);
  if (fromGoogleSearchRetrieval != null) {
    common.setValueByPath(
      toObject,
      ['googleSearchRetrieval'],
      googleSearchRetrievalToVertex(apiClient, fromGoogleSearchRetrieval),
    );
  }

  const fromCodeExecution = common.getValueByPath(fromObject, [
    'codeExecution',
  ]);
  if (fromCodeExecution != null) {
    common.setValueByPath(toObject, ['codeExecution'], fromCodeExecution);
  }

  return toObject;
}

function functionCallingConfigToMldev(
  apiClient: ApiClient,
  fromObject: types.FunctionCallingConfig,
): Record<string, unknown> {
  const toObject: Record<string, unknown> = {};

  const fromMode = common.getValueByPath(fromObject, ['mode']);
  if (fromMode != null) {
    common.setValueByPath(toObject, ['mode'], fromMode);
  }

  const fromAllowedFunctionNames = common.getValueByPath(fromObject, [
    'allowedFunctionNames',
  ]);
  if (fromAllowedFunctionNames != null) {
    common.setValueByPath(
      toObject,
      ['allowedFunctionNames'],
      fromAllowedFunctionNames,
    );
  }

  return toObject;
}

function functionCallingConfigToVertex(
  apiClient: ApiClient,
  fromObject: types.FunctionCallingConfig,
): Record<string, unknown> {
  const toObject: Record<string, unknown> = {};

  const fromMode = common.getValueByPath(fromObject, ['mode']);
  if (fromMode != null) {
    common.setValueByPath(toObject, ['mode'], fromMode);
  }

  const fromAllowedFunctionNames = common.getValueByPath(fromObject, [
    'allowedFunctionNames',
  ]);
  if (fromAllowedFunctionNames != null) {
    common.setValueByPath(
      toObject,
      ['allowedFunctionNames'],
      fromAllowedFunctionNames,
    );
  }

  return toObject;
}

function toolConfigToMldev(
  apiClient: ApiClient,
  fromObject: types.ToolConfig,
): Record<string, unknown> {
  const toObject: Record<string, unknown> = {};

  const fromFunctionCallingConfig = common.getValueByPath(fromObject, [
    'functionCallingConfig',
  ]);
  if (fromFunctionCallingConfig != null) {
    common.setValueByPath(
      toObject,
      ['functionCallingConfig'],
      functionCallingConfigToMldev(apiClient, fromFunctionCallingConfig),
    );
  }

  return toObject;
}

function toolConfigToVertex(
  apiClient: ApiClient,
  fromObject: types.ToolConfig,
): Record<string, unknown> {
  const toObject: Record<string, unknown> = {};

  const fromFunctionCallingConfig = common.getValueByPath(fromObject, [
    'functionCallingConfig',
  ]);
  if (fromFunctionCallingConfig != null) {
    common.setValueByPath(
      toObject,
      ['functionCallingConfig'],
      functionCallingConfigToVertex(apiClient, fromFunctionCallingConfig),
    );
  }

  return toObject;
}

function prebuiltVoiceConfigToMldev(
  apiClient: ApiClient,
  fromObject: types.PrebuiltVoiceConfig,
): Record<string, unknown> {
  const toObject: Record<string, unknown> = {};

  const fromVoiceName = common.getValueByPath(fromObject, ['voiceName']);
  if (fromVoiceName != null) {
    common.setValueByPath(toObject, ['voiceName'], fromVoiceName);
  }

  return toObject;
}

function prebuiltVoiceConfigToVertex(
  apiClient: ApiClient,
  fromObject: types.PrebuiltVoiceConfig,
): Record<string, unknown> {
  const toObject: Record<string, unknown> = {};

  const fromVoiceName = common.getValueByPath(fromObject, ['voiceName']);
  if (fromVoiceName != null) {
    common.setValueByPath(toObject, ['voiceName'], fromVoiceName);
  }

  return toObject;
}

function voiceConfigToMldev(
  apiClient: ApiClient,
  fromObject: types.VoiceConfig,
): Record<string, unknown> {
  const toObject: Record<string, unknown> = {};

  const fromPrebuiltVoiceConfig = common.getValueByPath(fromObject, [
    'prebuiltVoiceConfig',
  ]);
  if (fromPrebuiltVoiceConfig != null) {
    common.setValueByPath(
      toObject,
      ['prebuiltVoiceConfig'],
      prebuiltVoiceConfigToMldev(apiClient, fromPrebuiltVoiceConfig),
    );
  }

  return toObject;
}

function voiceConfigToVertex(
  apiClient: ApiClient,
  fromObject: types.VoiceConfig,
): Record<string, unknown> {
  const toObject: Record<string, unknown> = {};

  const fromPrebuiltVoiceConfig = common.getValueByPath(fromObject, [
    'prebuiltVoiceConfig',
  ]);
  if (fromPrebuiltVoiceConfig != null) {
    common.setValueByPath(
      toObject,
      ['prebuiltVoiceConfig'],
      prebuiltVoiceConfigToVertex(apiClient, fromPrebuiltVoiceConfig),
    );
  }

  return toObject;
}

function speechConfigToMldev(
  apiClient: ApiClient,
  fromObject: types.SpeechConfig,
): Record<string, unknown> {
  const toObject: Record<string, unknown> = {};

  const fromVoiceConfig = common.getValueByPath(fromObject, ['voiceConfig']);
  if (fromVoiceConfig != null) {
    common.setValueByPath(
      toObject,
      ['voiceConfig'],
      voiceConfigToMldev(apiClient, fromVoiceConfig),
    );
  }

  return toObject;
}

function speechConfigToVertex(
  apiClient: ApiClient,
  fromObject: types.SpeechConfig,
): Record<string, unknown> {
  const toObject: Record<string, unknown> = {};

  const fromVoiceConfig = common.getValueByPath(fromObject, ['voiceConfig']);
  if (fromVoiceConfig != null) {
    common.setValueByPath(
      toObject,
      ['voiceConfig'],
      voiceConfigToVertex(apiClient, fromVoiceConfig),
    );
  }

  return toObject;
}

function thinkingConfigToMldev(
  apiClient: ApiClient,
  fromObject: types.ThinkingConfig,
): Record<string, unknown> {
  const toObject: Record<string, unknown> = {};

  const fromIncludeThoughts = common.getValueByPath(fromObject, [
    'includeThoughts',
  ]);
  if (fromIncludeThoughts != null) {
    common.setValueByPath(toObject, ['includeThoughts'], fromIncludeThoughts);
  }

  return toObject;
}

function thinkingConfigToVertex(
  apiClient: ApiClient,
  fromObject: types.ThinkingConfig,
): Record<string, unknown> {
  const toObject: Record<string, unknown> = {};

  const fromIncludeThoughts = common.getValueByPath(fromObject, [
    'includeThoughts',
  ]);
  if (fromIncludeThoughts != null) {
    common.setValueByPath(toObject, ['includeThoughts'], fromIncludeThoughts);
  }

  return toObject;
}

function generateContentConfigToMldev(
  apiClient: ApiClient,
  fromObject: types.GenerateContentConfig,
  parentObject: Record<string, unknown>,
): Record<string, unknown> {
  const toObject: Record<string, unknown> = {};

  const fromSystemInstruction = common.getValueByPath(fromObject, [
    'systemInstruction',
  ]);
  if (parentObject !== undefined && fromSystemInstruction != null) {
    common.setValueByPath(
      parentObject,
      ['systemInstruction'],
      contentToMldev(apiClient, t.tContent(apiClient, fromSystemInstruction)),
    );
  }

  const fromTemperature = common.getValueByPath(fromObject, ['temperature']);
  if (fromTemperature != null) {
    common.setValueByPath(toObject, ['temperature'], fromTemperature);
  }

  const fromTopP = common.getValueByPath(fromObject, ['topP']);
  if (fromTopP != null) {
    common.setValueByPath(toObject, ['topP'], fromTopP);
  }

  const fromTopK = common.getValueByPath(fromObject, ['topK']);
  if (fromTopK != null) {
    common.setValueByPath(toObject, ['topK'], fromTopK);
  }

  const fromCandidateCount = common.getValueByPath(fromObject, [
    'candidateCount',
  ]);
  if (fromCandidateCount != null) {
    common.setValueByPath(toObject, ['candidateCount'], fromCandidateCount);
  }

  const fromMaxOutputTokens = common.getValueByPath(fromObject, [
    'maxOutputTokens',
  ]);
  if (fromMaxOutputTokens != null) {
    common.setValueByPath(toObject, ['maxOutputTokens'], fromMaxOutputTokens);
  }

  const fromStopSequences = common.getValueByPath(fromObject, [
    'stopSequences',
  ]);
  if (fromStopSequences != null) {
    common.setValueByPath(toObject, ['stopSequences'], fromStopSequences);
  }

  const fromResponseLogprobs = common.getValueByPath(fromObject, [
    'responseLogprobs',
  ]);
  if (fromResponseLogprobs != null) {
    common.setValueByPath(toObject, ['responseLogprobs'], fromResponseLogprobs);
  }

  const fromLogprobs = common.getValueByPath(fromObject, ['logprobs']);
  if (fromLogprobs != null) {
    common.setValueByPath(toObject, ['logprobs'], fromLogprobs);
  }

  const fromPresencePenalty = common.getValueByPath(fromObject, [
    'presencePenalty',
  ]);
  if (fromPresencePenalty != null) {
    common.setValueByPath(toObject, ['presencePenalty'], fromPresencePenalty);
  }

  const fromFrequencyPenalty = common.getValueByPath(fromObject, [
    'frequencyPenalty',
  ]);
  if (fromFrequencyPenalty != null) {
    common.setValueByPath(toObject, ['frequencyPenalty'], fromFrequencyPenalty);
  }

  const fromSeed = common.getValueByPath(fromObject, ['seed']);
  if (fromSeed != null) {
    common.setValueByPath(toObject, ['seed'], fromSeed);
  }

  const fromResponseMimeType = common.getValueByPath(fromObject, [
    'responseMimeType',
  ]);
  if (fromResponseMimeType != null) {
    common.setValueByPath(toObject, ['responseMimeType'], fromResponseMimeType);
  }

  const fromResponseSchema = common.getValueByPath(fromObject, [
    'responseSchema',
  ]);
  if (fromResponseSchema != null) {
    common.setValueByPath(
      toObject,
      ['responseSchema'],
      schemaToMldev(apiClient, t.tSchema(apiClient, fromResponseSchema)),
    );
  }

  if (common.getValueByPath(fromObject, ['routingConfig']) !== undefined) {
    throw new Error('routingConfig parameter is not supported in Gemini API.');
  }

  const fromSafetySettings = common.getValueByPath(fromObject, [
    'safetySettings',
  ]);
  if (parentObject !== undefined && fromSafetySettings != null) {
    if (Array.isArray(fromSafetySettings)) {
      common.setValueByPath(
        parentObject,
        ['safetySettings'],
        fromSafetySettings.map((item) => {
          return safetySettingToMldev(apiClient, item);
        }),
      );
    } else {
      common.setValueByPath(
        parentObject,
        ['safetySettings'],
        fromSafetySettings,
      );
    }
  }

  const fromTools = common.getValueByPath(fromObject, ['tools']);
  if (parentObject !== undefined && fromTools != null) {
    if (Array.isArray(fromTools)) {
      common.setValueByPath(
        parentObject,
        ['tools'],
        t.tTools(apiClient, fromTools).map((item) => {
          return toolToMldev(apiClient, t.tTool(apiClient, item));
        }),
      );
    } else {
      common.setValueByPath(
        parentObject,
        ['tools'],
        t.tTools(apiClient, fromTools),
      );
    }
  }

  const fromToolConfig = common.getValueByPath(fromObject, ['toolConfig']);
  if (parentObject !== undefined && fromToolConfig != null) {
    common.setValueByPath(
      parentObject,
      ['toolConfig'],
      toolConfigToMldev(apiClient, fromToolConfig),
    );
  }

  if (common.getValueByPath(fromObject, ['labels']) !== undefined) {
    throw new Error('labels parameter is not supported in Gemini API.');
  }

  const fromCachedContent = common.getValueByPath(fromObject, [
    'cachedContent',
  ]);
  if (parentObject !== undefined && fromCachedContent != null) {
    common.setValueByPath(
      parentObject,
      ['cachedContent'],
      t.tCachedContentName(apiClient, fromCachedContent),
    );
  }

  const fromResponseModalities = common.getValueByPath(fromObject, [
    'responseModalities',
  ]);
  if (fromResponseModalities != null) {
    common.setValueByPath(
      toObject,
      ['responseModalities'],
      fromResponseModalities,
    );
  }

  const fromMediaResolution = common.getValueByPath(fromObject, [
    'mediaResolution',
  ]);
  if (fromMediaResolution != null) {
    common.setValueByPath(toObject, ['mediaResolution'], fromMediaResolution);
  }

  const fromSpeechConfig = common.getValueByPath(fromObject, ['speechConfig']);
  if (fromSpeechConfig != null) {
    common.setValueByPath(
      toObject,
      ['speechConfig'],
      speechConfigToMldev(
        apiClient,
        t.tSpeechConfig(apiClient, fromSpeechConfig),
      ),
    );
  }

  if (common.getValueByPath(fromObject, ['audioTimestamp']) !== undefined) {
    throw new Error('audioTimestamp parameter is not supported in Gemini API.');
  }

  const fromThinkingConfig = common.getValueByPath(fromObject, [
    'thinkingConfig',
  ]);
  if (fromThinkingConfig != null) {
    common.setValueByPath(
      toObject,
      ['thinkingConfig'],
      thinkingConfigToMldev(apiClient, fromThinkingConfig),
    );
  }

  return toObject;
}

function generateContentConfigToVertex(
  apiClient: ApiClient,
  fromObject: types.GenerateContentConfig,
  parentObject: Record<string, unknown>,
): Record<string, unknown> {
  const toObject: Record<string, unknown> = {};

  const fromSystemInstruction = common.getValueByPath(fromObject, [
    'systemInstruction',
  ]);
  if (parentObject !== undefined && fromSystemInstruction != null) {
    common.setValueByPath(
      parentObject,
      ['systemInstruction'],
      contentToVertex(apiClient, t.tContent(apiClient, fromSystemInstruction)),
    );
  }

  const fromTemperature = common.getValueByPath(fromObject, ['temperature']);
  if (fromTemperature != null) {
    common.setValueByPath(toObject, ['temperature'], fromTemperature);
  }

  const fromTopP = common.getValueByPath(fromObject, ['topP']);
  if (fromTopP != null) {
    common.setValueByPath(toObject, ['topP'], fromTopP);
  }

  const fromTopK = common.getValueByPath(fromObject, ['topK']);
  if (fromTopK != null) {
    common.setValueByPath(toObject, ['topK'], fromTopK);
  }

  const fromCandidateCount = common.getValueByPath(fromObject, [
    'candidateCount',
  ]);
  if (fromCandidateCount != null) {
    common.setValueByPath(toObject, ['candidateCount'], fromCandidateCount);
  }

  const fromMaxOutputTokens = common.getValueByPath(fromObject, [
    'maxOutputTokens',
  ]);
  if (fromMaxOutputTokens != null) {
    common.setValueByPath(toObject, ['maxOutputTokens'], fromMaxOutputTokens);
  }

  const fromStopSequences = common.getValueByPath(fromObject, [
    'stopSequences',
  ]);
  if (fromStopSequences != null) {
    common.setValueByPath(toObject, ['stopSequences'], fromStopSequences);
  }

  const fromResponseLogprobs = common.getValueByPath(fromObject, [
    'responseLogprobs',
  ]);
  if (fromResponseLogprobs != null) {
    common.setValueByPath(toObject, ['responseLogprobs'], fromResponseLogprobs);
  }

  const fromLogprobs = common.getValueByPath(fromObject, ['logprobs']);
  if (fromLogprobs != null) {
    common.setValueByPath(toObject, ['logprobs'], fromLogprobs);
  }

  const fromPresencePenalty = common.getValueByPath(fromObject, [
    'presencePenalty',
  ]);
  if (fromPresencePenalty != null) {
    common.setValueByPath(toObject, ['presencePenalty'], fromPresencePenalty);
  }

  const fromFrequencyPenalty = common.getValueByPath(fromObject, [
    'frequencyPenalty',
  ]);
  if (fromFrequencyPenalty != null) {
    common.setValueByPath(toObject, ['frequencyPenalty'], fromFrequencyPenalty);
  }

  const fromSeed = common.getValueByPath(fromObject, ['seed']);
  if (fromSeed != null) {
    common.setValueByPath(toObject, ['seed'], fromSeed);
  }

  const fromResponseMimeType = common.getValueByPath(fromObject, [
    'responseMimeType',
  ]);
  if (fromResponseMimeType != null) {
    common.setValueByPath(toObject, ['responseMimeType'], fromResponseMimeType);
  }

  const fromResponseSchema = common.getValueByPath(fromObject, [
    'responseSchema',
  ]);
  if (fromResponseSchema != null) {
    common.setValueByPath(
      toObject,
      ['responseSchema'],
      schemaToVertex(apiClient, t.tSchema(apiClient, fromResponseSchema)),
    );
  }

  const fromRoutingConfig = common.getValueByPath(fromObject, [
    'routingConfig',
  ]);
  if (fromRoutingConfig != null) {
    common.setValueByPath(toObject, ['routingConfig'], fromRoutingConfig);
  }

  const fromSafetySettings = common.getValueByPath(fromObject, [
    'safetySettings',
  ]);
  if (parentObject !== undefined && fromSafetySettings != null) {
    if (Array.isArray(fromSafetySettings)) {
      common.setValueByPath(
        parentObject,
        ['safetySettings'],
        fromSafetySettings.map((item) => {
          return safetySettingToVertex(apiClient, item);
        }),
      );
    } else {
      common.setValueByPath(
        parentObject,
        ['safetySettings'],
        fromSafetySettings,
      );
    }
  }

  const fromTools = common.getValueByPath(fromObject, ['tools']);
  if (parentObject !== undefined && fromTools != null) {
    if (Array.isArray(fromTools)) {
      common.setValueByPath(
        parentObject,
        ['tools'],
        t.tTools(apiClient, fromTools).map((item) => {
          return toolToVertex(apiClient, t.tTool(apiClient, item));
        }),
      );
    } else {
      common.setValueByPath(
        parentObject,
        ['tools'],
        t.tTools(apiClient, fromTools),
      );
    }
  }

  const fromToolConfig = common.getValueByPath(fromObject, ['toolConfig']);
  if (parentObject !== undefined && fromToolConfig != null) {
    common.setValueByPath(
      parentObject,
      ['toolConfig'],
      toolConfigToVertex(apiClient, fromToolConfig),
    );
  }

  const fromLabels = common.getValueByPath(fromObject, ['labels']);
  if (parentObject !== undefined && fromLabels != null) {
    common.setValueByPath(parentObject, ['labels'], fromLabels);
  }

  const fromCachedContent = common.getValueByPath(fromObject, [
    'cachedContent',
  ]);
  if (parentObject !== undefined && fromCachedContent != null) {
    common.setValueByPath(
      parentObject,
      ['cachedContent'],
      t.tCachedContentName(apiClient, fromCachedContent),
    );
  }

  const fromResponseModalities = common.getValueByPath(fromObject, [
    'responseModalities',
  ]);
  if (fromResponseModalities != null) {
    common.setValueByPath(
      toObject,
      ['responseModalities'],
      fromResponseModalities,
    );
  }

  const fromMediaResolution = common.getValueByPath(fromObject, [
    'mediaResolution',
  ]);
  if (fromMediaResolution != null) {
    common.setValueByPath(toObject, ['mediaResolution'], fromMediaResolution);
  }

  const fromSpeechConfig = common.getValueByPath(fromObject, ['speechConfig']);
  if (fromSpeechConfig != null) {
    common.setValueByPath(
      toObject,
      ['speechConfig'],
      speechConfigToVertex(
        apiClient,
        t.tSpeechConfig(apiClient, fromSpeechConfig),
      ),
    );
  }

  const fromAudioTimestamp = common.getValueByPath(fromObject, [
    'audioTimestamp',
  ]);
  if (fromAudioTimestamp != null) {
    common.setValueByPath(toObject, ['audioTimestamp'], fromAudioTimestamp);
  }

  const fromThinkingConfig = common.getValueByPath(fromObject, [
    'thinkingConfig',
  ]);
  if (fromThinkingConfig != null) {
    common.setValueByPath(
      toObject,
      ['thinkingConfig'],
      thinkingConfigToVertex(apiClient, fromThinkingConfig),
    );
  }

  return toObject;
}

function generateContentParametersToMldev(
  apiClient: ApiClient,
  fromObject: types.GenerateContentParameters,
): Record<string, unknown> {
  const toObject: Record<string, unknown> = {};

  const fromModel = common.getValueByPath(fromObject, ['model']);
  if (fromModel != null) {
    common.setValueByPath(
      toObject,
      ['_url', 'model'],
      t.tModel(apiClient, fromModel),
    );
  }

  const fromContents = common.getValueByPath(fromObject, ['contents']);
  if (fromContents != null) {
    if (Array.isArray(fromContents)) {
      common.setValueByPath(
        toObject,
        ['contents'],
        t.tContents(apiClient, fromContents).map((item) => {
          return contentToMldev(apiClient, item);
        }),
      );
    } else {
      common.setValueByPath(
        toObject,
        ['contents'],
        t.tContents(apiClient, fromContents),
      );
    }
  }

  const fromConfig = common.getValueByPath(fromObject, ['config']);
  if (fromConfig != null) {
    common.setValueByPath(
      toObject,
      ['generationConfig'],
      generateContentConfigToMldev(apiClient, fromConfig, toObject),
    );
  }

  return toObject;
}

function generateContentParametersToVertex(
  apiClient: ApiClient,
  fromObject: types.GenerateContentParameters,
): Record<string, unknown> {
  const toObject: Record<string, unknown> = {};

  const fromModel = common.getValueByPath(fromObject, ['model']);
  if (fromModel != null) {
    common.setValueByPath(
      toObject,
      ['_url', 'model'],
      t.tModel(apiClient, fromModel),
    );
  }

  const fromContents = common.getValueByPath(fromObject, ['contents']);
  if (fromContents != null) {
    if (Array.isArray(fromContents)) {
      common.setValueByPath(
        toObject,
        ['contents'],
        t.tContents(apiClient, fromContents).map((item) => {
          return contentToVertex(apiClient, item);
        }),
      );
    } else {
      common.setValueByPath(
        toObject,
        ['contents'],
        t.tContents(apiClient, fromContents),
      );
    }
  }

  const fromConfig = common.getValueByPath(fromObject, ['config']);
  if (fromConfig != null) {
    common.setValueByPath(
      toObject,
      ['generationConfig'],
      generateContentConfigToVertex(apiClient, fromConfig, toObject),
    );
  }

  return toObject;
}

function embedContentConfigToMldev(
  apiClient: ApiClient,
  fromObject: types.EmbedContentConfig,
  parentObject: Record<string, unknown>,
): Record<string, unknown> {
  const toObject: Record<string, unknown> = {};

  const fromTaskType = common.getValueByPath(fromObject, ['taskType']);
  if (parentObject !== undefined && fromTaskType != null) {
    common.setValueByPath(
      parentObject,
      ['requests[]', 'taskType'],
      fromTaskType,
    );
  }

  const fromTitle = common.getValueByPath(fromObject, ['title']);
  if (parentObject !== undefined && fromTitle != null) {
    common.setValueByPath(parentObject, ['requests[]', 'title'], fromTitle);
  }

  const fromOutputDimensionality = common.getValueByPath(fromObject, [
    'outputDimensionality',
  ]);
  if (parentObject !== undefined && fromOutputDimensionality != null) {
    common.setValueByPath(
      parentObject,
      ['requests[]', 'outputDimensionality'],
      fromOutputDimensionality,
    );
  }

  if (common.getValueByPath(fromObject, ['mimeType']) !== undefined) {
    throw new Error('mimeType parameter is not supported in Gemini API.');
  }

  if (common.getValueByPath(fromObject, ['autoTruncate']) !== undefined) {
    throw new Error('autoTruncate parameter is not supported in Gemini API.');
  }

  return toObject;
}

function embedContentConfigToVertex(
  apiClient: ApiClient,
  fromObject: types.EmbedContentConfig,
  parentObject: Record<string, unknown>,
): Record<string, unknown> {
  const toObject: Record<string, unknown> = {};

  const fromTaskType = common.getValueByPath(fromObject, ['taskType']);
  if (parentObject !== undefined && fromTaskType != null) {
    common.setValueByPath(
      parentObject,
      ['instances[]', 'task_type'],
      fromTaskType,
    );
  }

  const fromTitle = common.getValueByPath(fromObject, ['title']);
  if (parentObject !== undefined && fromTitle != null) {
    common.setValueByPath(parentObject, ['instances[]', 'title'], fromTitle);
  }

  const fromOutputDimensionality = common.getValueByPath(fromObject, [
    'outputDimensionality',
  ]);
  if (parentObject !== undefined && fromOutputDimensionality != null) {
    common.setValueByPath(
      parentObject,
      ['parameters', 'outputDimensionality'],
      fromOutputDimensionality,
    );
  }

  const fromMimeType = common.getValueByPath(fromObject, ['mimeType']);
  if (parentObject !== undefined && fromMimeType != null) {
    common.setValueByPath(
      parentObject,
      ['instances[]', 'mimeType'],
      fromMimeType,
    );
  }

  const fromAutoTruncate = common.getValueByPath(fromObject, ['autoTruncate']);
  if (parentObject !== undefined && fromAutoTruncate != null) {
    common.setValueByPath(
      parentObject,
      ['parameters', 'autoTruncate'],
      fromAutoTruncate,
    );
  }

  return toObject;
}

function embedContentParametersToMldev(
  apiClient: ApiClient,
  fromObject: types.EmbedContentParameters,
): Record<string, unknown> {
  const toObject: Record<string, unknown> = {};

  const fromModel = common.getValueByPath(fromObject, ['model']);
  if (fromModel != null) {
    common.setValueByPath(
      toObject,
      ['_url', 'model'],
      t.tModel(apiClient, fromModel),
    );
  }

  const fromContents = common.getValueByPath(fromObject, ['contents']);
  if (fromContents != null) {
    common.setValueByPath(
      toObject,
      ['requests[]', 'content'],
      t.tContentsForEmbed(apiClient, fromContents),
    );
  }

  const fromConfig = common.getValueByPath(fromObject, ['config']);
  if (fromConfig != null) {
    common.setValueByPath(
      toObject,
      ['config'],
      embedContentConfigToMldev(apiClient, fromConfig, toObject),
    );
  }

  const fromModelForEmbedContent = common.getValueByPath(fromObject, ['model']);
  if (fromModelForEmbedContent !== undefined) {
    common.setValueByPath(
      toObject,
      ['requests[]', 'model'],
      t.tModel(apiClient, fromModelForEmbedContent),
    );
  }

  return toObject;
}

function embedContentParametersToVertex(
  apiClient: ApiClient,
  fromObject: types.EmbedContentParameters,
): Record<string, unknown> {
  const toObject: Record<string, unknown> = {};

  const fromModel = common.getValueByPath(fromObject, ['model']);
  if (fromModel != null) {
    common.setValueByPath(
      toObject,
      ['_url', 'model'],
      t.tModel(apiClient, fromModel),
    );
  }

  const fromContents = common.getValueByPath(fromObject, ['contents']);
  if (fromContents != null) {
    common.setValueByPath(
      toObject,
      ['instances[]', 'content'],
      t.tContentsForEmbed(apiClient, fromContents),
    );
  }

  const fromConfig = common.getValueByPath(fromObject, ['config']);
  if (fromConfig != null) {
    common.setValueByPath(
      toObject,
      ['config'],
      embedContentConfigToVertex(apiClient, fromConfig, toObject),
    );
  }

  return toObject;
}

function generateImagesConfigToMldev(
  apiClient: ApiClient,
  fromObject: types.GenerateImagesConfig,
  parentObject: Record<string, unknown>,
): Record<string, unknown> {
  const toObject: Record<string, unknown> = {};

  if (common.getValueByPath(fromObject, ['outputGcsUri']) !== undefined) {
    throw new Error('outputGcsUri parameter is not supported in Gemini API.');
  }

  if (common.getValueByPath(fromObject, ['negativePrompt']) !== undefined) {
    throw new Error('negativePrompt parameter is not supported in Gemini API.');
  }

  const fromNumberOfImages = common.getValueByPath(fromObject, [
    'numberOfImages',
  ]);
  if (parentObject !== undefined && fromNumberOfImages != null) {
    common.setValueByPath(
      parentObject,
      ['parameters', 'sampleCount'],
      fromNumberOfImages,
    );
  }

  const fromAspectRatio = common.getValueByPath(fromObject, ['aspectRatio']);
  if (parentObject !== undefined && fromAspectRatio != null) {
    common.setValueByPath(
      parentObject,
      ['parameters', 'aspectRatio'],
      fromAspectRatio,
    );
  }

  const fromGuidanceScale = common.getValueByPath(fromObject, [
    'guidanceScale',
  ]);
  if (parentObject !== undefined && fromGuidanceScale != null) {
    common.setValueByPath(
      parentObject,
      ['parameters', 'guidanceScale'],
      fromGuidanceScale,
    );
  }

  if (common.getValueByPath(fromObject, ['seed']) !== undefined) {
    throw new Error('seed parameter is not supported in Gemini API.');
  }

  const fromSafetyFilterLevel = common.getValueByPath(fromObject, [
    'safetyFilterLevel',
  ]);
  if (parentObject !== undefined && fromSafetyFilterLevel != null) {
    common.setValueByPath(
      parentObject,
      ['parameters', 'safetySetting'],
      fromSafetyFilterLevel,
    );
  }

  const fromPersonGeneration = common.getValueByPath(fromObject, [
    'personGeneration',
  ]);
  if (parentObject !== undefined && fromPersonGeneration != null) {
    common.setValueByPath(
      parentObject,
      ['parameters', 'personGeneration'],
      fromPersonGeneration,
    );
  }

  const fromIncludeSafetyAttributes = common.getValueByPath(fromObject, [
    'includeSafetyAttributes',
  ]);
  if (parentObject !== undefined && fromIncludeSafetyAttributes != null) {
    common.setValueByPath(
      parentObject,
      ['parameters', 'includeSafetyAttributes'],
      fromIncludeSafetyAttributes,
    );
  }

  const fromIncludeRaiReason = common.getValueByPath(fromObject, [
    'includeRaiReason',
  ]);
  if (parentObject !== undefined && fromIncludeRaiReason != null) {
    common.setValueByPath(
      parentObject,
      ['parameters', 'includeRaiReason'],
      fromIncludeRaiReason,
    );
  }

  const fromLanguage = common.getValueByPath(fromObject, ['language']);
  if (parentObject !== undefined && fromLanguage != null) {
    common.setValueByPath(
      parentObject,
      ['parameters', 'language'],
      fromLanguage,
    );
  }

  const fromOutputMimeType = common.getValueByPath(fromObject, [
    'outputMimeType',
  ]);
  if (parentObject !== undefined && fromOutputMimeType != null) {
    common.setValueByPath(
      parentObject,
      ['parameters', 'outputOptions', 'mimeType'],
      fromOutputMimeType,
    );
  }

  const fromOutputCompressionQuality = common.getValueByPath(fromObject, [
    'outputCompressionQuality',
  ]);
  if (parentObject !== undefined && fromOutputCompressionQuality != null) {
    common.setValueByPath(
      parentObject,
      ['parameters', 'outputOptions', 'compressionQuality'],
      fromOutputCompressionQuality,
    );
  }

  if (common.getValueByPath(fromObject, ['addWatermark']) !== undefined) {
    throw new Error('addWatermark parameter is not supported in Gemini API.');
  }

  if (common.getValueByPath(fromObject, ['enhancePrompt']) !== undefined) {
    throw new Error('enhancePrompt parameter is not supported in Gemini API.');
  }

  return toObject;
}

function generateImagesConfigToVertex(
  apiClient: ApiClient,
  fromObject: types.GenerateImagesConfig,
  parentObject: Record<string, unknown>,
): Record<string, unknown> {
  const toObject: Record<string, unknown> = {};

  const fromOutputGcsUri = common.getValueByPath(fromObject, ['outputGcsUri']);
  if (parentObject !== undefined && fromOutputGcsUri != null) {
    common.setValueByPath(
      parentObject,
      ['parameters', 'storageUri'],
      fromOutputGcsUri,
    );
  }

  const fromNegativePrompt = common.getValueByPath(fromObject, [
    'negativePrompt',
  ]);
  if (parentObject !== undefined && fromNegativePrompt != null) {
    common.setValueByPath(
      parentObject,
      ['parameters', 'negativePrompt'],
      fromNegativePrompt,
    );
  }

  const fromNumberOfImages = common.getValueByPath(fromObject, [
    'numberOfImages',
  ]);
  if (parentObject !== undefined && fromNumberOfImages != null) {
    common.setValueByPath(
      parentObject,
      ['parameters', 'sampleCount'],
      fromNumberOfImages,
    );
  }

  const fromAspectRatio = common.getValueByPath(fromObject, ['aspectRatio']);
  if (parentObject !== undefined && fromAspectRatio != null) {
    common.setValueByPath(
      parentObject,
      ['parameters', 'aspectRatio'],
      fromAspectRatio,
    );
  }

  const fromGuidanceScale = common.getValueByPath(fromObject, [
    'guidanceScale',
  ]);
  if (parentObject !== undefined && fromGuidanceScale != null) {
    common.setValueByPath(
      parentObject,
      ['parameters', 'guidanceScale'],
      fromGuidanceScale,
    );
  }

  const fromSeed = common.getValueByPath(fromObject, ['seed']);
  if (parentObject !== undefined && fromSeed != null) {
    common.setValueByPath(parentObject, ['parameters', 'seed'], fromSeed);
  }

  const fromSafetyFilterLevel = common.getValueByPath(fromObject, [
    'safetyFilterLevel',
  ]);
  if (parentObject !== undefined && fromSafetyFilterLevel != null) {
    common.setValueByPath(
      parentObject,
      ['parameters', 'safetySetting'],
      fromSafetyFilterLevel,
    );
  }

  const fromPersonGeneration = common.getValueByPath(fromObject, [
    'personGeneration',
  ]);
  if (parentObject !== undefined && fromPersonGeneration != null) {
    common.setValueByPath(
      parentObject,
      ['parameters', 'personGeneration'],
      fromPersonGeneration,
    );
  }

  const fromIncludeSafetyAttributes = common.getValueByPath(fromObject, [
    'includeSafetyAttributes',
  ]);
  if (parentObject !== undefined && fromIncludeSafetyAttributes != null) {
    common.setValueByPath(
      parentObject,
      ['parameters', 'includeSafetyAttributes'],
      fromIncludeSafetyAttributes,
    );
  }

  const fromIncludeRaiReason = common.getValueByPath(fromObject, [
    'includeRaiReason',
  ]);
  if (parentObject !== undefined && fromIncludeRaiReason != null) {
    common.setValueByPath(
      parentObject,
      ['parameters', 'includeRaiReason'],
      fromIncludeRaiReason,
    );
  }

  const fromLanguage = common.getValueByPath(fromObject, ['language']);
  if (parentObject !== undefined && fromLanguage != null) {
    common.setValueByPath(
      parentObject,
      ['parameters', 'language'],
      fromLanguage,
    );
  }

  const fromOutputMimeType = common.getValueByPath(fromObject, [
    'outputMimeType',
  ]);
  if (parentObject !== undefined && fromOutputMimeType != null) {
    common.setValueByPath(
      parentObject,
      ['parameters', 'outputOptions', 'mimeType'],
      fromOutputMimeType,
    );
  }

  const fromOutputCompressionQuality = common.getValueByPath(fromObject, [
    'outputCompressionQuality',
  ]);
  if (parentObject !== undefined && fromOutputCompressionQuality != null) {
    common.setValueByPath(
      parentObject,
      ['parameters', 'outputOptions', 'compressionQuality'],
      fromOutputCompressionQuality,
    );
  }

  const fromAddWatermark = common.getValueByPath(fromObject, ['addWatermark']);
  if (parentObject !== undefined && fromAddWatermark != null) {
    common.setValueByPath(
      parentObject,
      ['parameters', 'addWatermark'],
      fromAddWatermark,
    );
  }

  const fromEnhancePrompt = common.getValueByPath(fromObject, [
    'enhancePrompt',
  ]);
  if (parentObject !== undefined && fromEnhancePrompt != null) {
    common.setValueByPath(
      parentObject,
      ['parameters', 'enhancePrompt'],
      fromEnhancePrompt,
    );
  }

  return toObject;
}

function generateImagesParametersToMldev(
  apiClient: ApiClient,
  fromObject: types.GenerateImagesParameters,
): Record<string, unknown> {
  const toObject: Record<string, unknown> = {};

  const fromModel = common.getValueByPath(fromObject, ['model']);
  if (fromModel != null) {
    common.setValueByPath(
      toObject,
      ['_url', 'model'],
      t.tModel(apiClient, fromModel),
    );
  }

  const fromPrompt = common.getValueByPath(fromObject, ['prompt']);
  if (fromPrompt != null) {
    common.setValueByPath(toObject, ['instances[0]', 'prompt'], fromPrompt);
  }

  const fromConfig = common.getValueByPath(fromObject, ['config']);
  if (fromConfig != null) {
    common.setValueByPath(
      toObject,
      ['config'],
      generateImagesConfigToMldev(apiClient, fromConfig, toObject),
    );
  }

  return toObject;
}

function generateImagesParametersToVertex(
  apiClient: ApiClient,
  fromObject: types.GenerateImagesParameters,
): Record<string, unknown> {
  const toObject: Record<string, unknown> = {};

  const fromModel = common.getValueByPath(fromObject, ['model']);
  if (fromModel != null) {
    common.setValueByPath(
      toObject,
      ['_url', 'model'],
      t.tModel(apiClient, fromModel),
    );
  }

  const fromPrompt = common.getValueByPath(fromObject, ['prompt']);
  if (fromPrompt != null) {
    common.setValueByPath(toObject, ['instances[0]', 'prompt'], fromPrompt);
  }

  const fromConfig = common.getValueByPath(fromObject, ['config']);
  if (fromConfig != null) {
    common.setValueByPath(
      toObject,
      ['config'],
      generateImagesConfigToVertex(apiClient, fromConfig, toObject),
    );
  }

  return toObject;
}

function countTokensConfigToMldev(
  apiClient: ApiClient,
  fromObject: types.CountTokensConfig,
): Record<string, unknown> {
  const toObject: Record<string, unknown> = {};

  if (common.getValueByPath(fromObject, ['systemInstruction']) !== undefined) {
    throw new Error(
      'systemInstruction parameter is not supported in Gemini API.',
    );
  }

  if (common.getValueByPath(fromObject, ['tools']) !== undefined) {
    throw new Error('tools parameter is not supported in Gemini API.');
  }

  if (common.getValueByPath(fromObject, ['generationConfig']) !== undefined) {
    throw new Error(
      'generationConfig parameter is not supported in Gemini API.',
    );
  }

  return toObject;
}

function countTokensConfigToVertex(
  apiClient: ApiClient,
  fromObject: types.CountTokensConfig,
  parentObject: Record<string, unknown>,
): Record<string, unknown> {
  const toObject: Record<string, unknown> = {};

  const fromSystemInstruction = common.getValueByPath(fromObject, [
    'systemInstruction',
  ]);
  if (parentObject !== undefined && fromSystemInstruction != null) {
    common.setValueByPath(
      parentObject,
      ['systemInstruction'],
      contentToVertex(apiClient, t.tContent(apiClient, fromSystemInstruction)),
    );
  }

  const fromTools = common.getValueByPath(fromObject, ['tools']);
  if (parentObject !== undefined && fromTools != null) {
    if (Array.isArray(fromTools)) {
      common.setValueByPath(
        parentObject,
        ['tools'],
        fromTools.map((item) => {
          return toolToVertex(apiClient, item);
        }),
      );
    } else {
      common.setValueByPath(parentObject, ['tools'], fromTools);
    }
  }

  const fromGenerationConfig = common.getValueByPath(fromObject, [
    'generationConfig',
  ]);
  if (parentObject !== undefined && fromGenerationConfig != null) {
    common.setValueByPath(
      parentObject,
      ['generationConfig'],
      fromGenerationConfig,
    );
  }

  return toObject;
}

function countTokensParametersToMldev(
  apiClient: ApiClient,
  fromObject: types.CountTokensParameters,
): Record<string, unknown> {
  const toObject: Record<string, unknown> = {};

  const fromModel = common.getValueByPath(fromObject, ['model']);
  if (fromModel != null) {
    common.setValueByPath(
      toObject,
      ['_url', 'model'],
      t.tModel(apiClient, fromModel),
    );
  }

  const fromContents = common.getValueByPath(fromObject, ['contents']);
  if (fromContents != null) {
    if (Array.isArray(fromContents)) {
      common.setValueByPath(
        toObject,
        ['contents'],
        t.tContents(apiClient, fromContents).map((item) => {
          return contentToMldev(apiClient, item);
        }),
      );
    } else {
      common.setValueByPath(
        toObject,
        ['contents'],
        t.tContents(apiClient, fromContents),
      );
    }
  }

  const fromConfig = common.getValueByPath(fromObject, ['config']);
  if (fromConfig != null) {
    common.setValueByPath(
      toObject,
      ['config'],
      countTokensConfigToMldev(apiClient, fromConfig),
    );
  }

  return toObject;
}

function countTokensParametersToVertex(
  apiClient: ApiClient,
  fromObject: types.CountTokensParameters,
): Record<string, unknown> {
  const toObject: Record<string, unknown> = {};

  const fromModel = common.getValueByPath(fromObject, ['model']);
  if (fromModel != null) {
    common.setValueByPath(
      toObject,
      ['_url', 'model'],
      t.tModel(apiClient, fromModel),
    );
  }

  const fromContents = common.getValueByPath(fromObject, ['contents']);
  if (fromContents != null) {
    if (Array.isArray(fromContents)) {
      common.setValueByPath(
        toObject,
        ['contents'],
        t.tContents(apiClient, fromContents).map((item) => {
          return contentToVertex(apiClient, item);
        }),
      );
    } else {
      common.setValueByPath(
        toObject,
        ['contents'],
        t.tContents(apiClient, fromContents),
      );
    }
  }

  const fromConfig = common.getValueByPath(fromObject, ['config']);
  if (fromConfig != null) {
    common.setValueByPath(
      toObject,
      ['config'],
      countTokensConfigToVertex(apiClient, fromConfig, toObject),
    );
  }

  return toObject;
}

function computeTokensParametersToMldev(
  apiClient: ApiClient,
  fromObject: types.ComputeTokensParameters,
): Record<string, unknown> {
  const toObject: Record<string, unknown> = {};

  const fromModel = common.getValueByPath(fromObject, ['model']);
  if (fromModel != null) {
    common.setValueByPath(
      toObject,
      ['_url', 'model'],
      t.tModel(apiClient, fromModel),
    );
  }

  if (common.getValueByPath(fromObject, ['contents']) !== undefined) {
    throw new Error('contents parameter is not supported in Gemini API.');
  }

  const fromConfig = common.getValueByPath(fromObject, ['config']);
  if (fromConfig != null) {
    common.setValueByPath(toObject, ['config'], fromConfig);
  }

  return toObject;
}

function computeTokensParametersToVertex(
  apiClient: ApiClient,
  fromObject: types.ComputeTokensParameters,
): Record<string, unknown> {
  const toObject: Record<string, unknown> = {};

  const fromModel = common.getValueByPath(fromObject, ['model']);
  if (fromModel != null) {
    common.setValueByPath(
      toObject,
      ['_url', 'model'],
      t.tModel(apiClient, fromModel),
    );
  }

  const fromContents = common.getValueByPath(fromObject, ['contents']);
  if (fromContents != null) {
    if (Array.isArray(fromContents)) {
      common.setValueByPath(
        toObject,
        ['contents'],
        t.tContents(apiClient, fromContents).map((item) => {
          return contentToVertex(apiClient, item);
        }),
      );
    } else {
      common.setValueByPath(
        toObject,
        ['contents'],
        t.tContents(apiClient, fromContents),
      );
    }
  }

  const fromConfig = common.getValueByPath(fromObject, ['config']);
  if (fromConfig != null) {
    common.setValueByPath(toObject, ['config'], fromConfig);
  }

  return toObject;
}

function partFromMldev(
  apiClient: ApiClient,
  fromObject: types.Part,
): Record<string, unknown> {
  const toObject: Record<string, unknown> = {};

  const fromThought = common.getValueByPath(fromObject, ['thought']);
  if (fromThought != null) {
    common.setValueByPath(toObject, ['thought'], fromThought);
  }

  const fromCodeExecutionResult = common.getValueByPath(fromObject, [
    'codeExecutionResult',
  ]);
  if (fromCodeExecutionResult != null) {
    common.setValueByPath(
      toObject,
      ['codeExecutionResult'],
      fromCodeExecutionResult,
    );
  }

  const fromExecutableCode = common.getValueByPath(fromObject, [
    'executableCode',
  ]);
  if (fromExecutableCode != null) {
    common.setValueByPath(toObject, ['executableCode'], fromExecutableCode);
  }

  const fromFileData = common.getValueByPath(fromObject, ['fileData']);
  if (fromFileData != null) {
    common.setValueByPath(toObject, ['fileData'], fromFileData);
  }

  const fromFunctionCall = common.getValueByPath(fromObject, ['functionCall']);
  if (fromFunctionCall != null) {
    common.setValueByPath(toObject, ['functionCall'], fromFunctionCall);
  }

  const fromFunctionResponse = common.getValueByPath(fromObject, [
    'functionResponse',
  ]);
  if (fromFunctionResponse != null) {
    common.setValueByPath(toObject, ['functionResponse'], fromFunctionResponse);
  }

  const fromInlineData = common.getValueByPath(fromObject, ['inlineData']);
  if (fromInlineData != null) {
    common.setValueByPath(toObject, ['inlineData'], fromInlineData);
  }

  const fromText = common.getValueByPath(fromObject, ['text']);
  if (fromText != null) {
    common.setValueByPath(toObject, ['text'], fromText);
  }

  return toObject;
}

function partFromVertex(
  apiClient: ApiClient,
  fromObject: types.Part,
): Record<string, unknown> {
  const toObject: Record<string, unknown> = {};

  const fromVideoMetadata = common.getValueByPath(fromObject, [
    'videoMetadata',
  ]);
  if (fromVideoMetadata != null) {
    common.setValueByPath(toObject, ['videoMetadata'], fromVideoMetadata);
  }

  const fromThought = common.getValueByPath(fromObject, ['thought']);
  if (fromThought != null) {
    common.setValueByPath(toObject, ['thought'], fromThought);
  }

  const fromCodeExecutionResult = common.getValueByPath(fromObject, [
    'codeExecutionResult',
  ]);
  if (fromCodeExecutionResult != null) {
    common.setValueByPath(
      toObject,
      ['codeExecutionResult'],
      fromCodeExecutionResult,
    );
  }

  const fromExecutableCode = common.getValueByPath(fromObject, [
    'executableCode',
  ]);
  if (fromExecutableCode != null) {
    common.setValueByPath(toObject, ['executableCode'], fromExecutableCode);
  }

  const fromFileData = common.getValueByPath(fromObject, ['fileData']);
  if (fromFileData != null) {
    common.setValueByPath(toObject, ['fileData'], fromFileData);
  }

  const fromFunctionCall = common.getValueByPath(fromObject, ['functionCall']);
  if (fromFunctionCall != null) {
    common.setValueByPath(toObject, ['functionCall'], fromFunctionCall);
  }

  const fromFunctionResponse = common.getValueByPath(fromObject, [
    'functionResponse',
  ]);
  if (fromFunctionResponse != null) {
    common.setValueByPath(toObject, ['functionResponse'], fromFunctionResponse);
  }

  const fromInlineData = common.getValueByPath(fromObject, ['inlineData']);
  if (fromInlineData != null) {
    common.setValueByPath(toObject, ['inlineData'], fromInlineData);
  }

  const fromText = common.getValueByPath(fromObject, ['text']);
  if (fromText != null) {
    common.setValueByPath(toObject, ['text'], fromText);
  }

  return toObject;
}

/** @internal */
export function contentFromMldev(
  apiClient: ApiClient,
  fromObject: types.Content,
): Record<string, unknown> {
  const toObject: Record<string, unknown> = {};

  const fromParts = common.getValueByPath(fromObject, ['parts']);
  if (fromParts != null) {
    if (Array.isArray(fromParts)) {
      common.setValueByPath(
        toObject,
        ['parts'],
        fromParts.map((item) => {
          return partFromMldev(apiClient, item);
        }),
      );
    } else {
      common.setValueByPath(toObject, ['parts'], fromParts);
    }
  }

  const fromRole = common.getValueByPath(fromObject, ['role']);
  if (fromRole != null) {
    common.setValueByPath(toObject, ['role'], fromRole);
  }

  return toObject;
}

/** @internal */
export function contentFromVertex(
  apiClient: ApiClient,
  fromObject: types.Content,
): Record<string, unknown> {
  const toObject: Record<string, unknown> = {};

  const fromParts = common.getValueByPath(fromObject, ['parts']);
  if (fromParts != null) {
    if (Array.isArray(fromParts)) {
      common.setValueByPath(
        toObject,
        ['parts'],
        fromParts.map((item) => {
          return partFromVertex(apiClient, item);
        }),
      );
    } else {
      common.setValueByPath(toObject, ['parts'], fromParts);
    }
  }

  const fromRole = common.getValueByPath(fromObject, ['role']);
  if (fromRole != null) {
    common.setValueByPath(toObject, ['role'], fromRole);
  }

  return toObject;
}

function citationMetadataFromMldev(
  apiClient: ApiClient,
  fromObject: types.CitationMetadata,
): Record<string, unknown> {
  const toObject: Record<string, unknown> = {};

  const fromCitations = common.getValueByPath(fromObject, ['citationSources']);
  if (fromCitations != null) {
    common.setValueByPath(toObject, ['citations'], fromCitations);
  }

  return toObject;
}

function citationMetadataFromVertex(
  apiClient: ApiClient,
  fromObject: types.CitationMetadata,
): Record<string, unknown> {
  const toObject: Record<string, unknown> = {};

  const fromCitations = common.getValueByPath(fromObject, ['citations']);
  if (fromCitations != null) {
    common.setValueByPath(toObject, ['citations'], fromCitations);
  }

  return toObject;
}

function candidateFromMldev(
  apiClient: ApiClient,
  fromObject: types.Candidate,
): Record<string, unknown> {
  const toObject: Record<string, unknown> = {};

  const fromContent = common.getValueByPath(fromObject, ['content']);
  if (fromContent != null) {
    common.setValueByPath(
      toObject,
      ['content'],
      contentFromMldev(apiClient, fromContent),
    );
  }

  const fromCitationMetadata = common.getValueByPath(fromObject, [
    'citationMetadata',
  ]);
  if (fromCitationMetadata != null) {
    common.setValueByPath(
      toObject,
      ['citationMetadata'],
      citationMetadataFromMldev(apiClient, fromCitationMetadata),
    );
  }

  const fromTokenCount = common.getValueByPath(fromObject, ['tokenCount']);
  if (fromTokenCount != null) {
    common.setValueByPath(toObject, ['tokenCount'], fromTokenCount);
  }

  const fromAvgLogprobs = common.getValueByPath(fromObject, ['avgLogprobs']);
  if (fromAvgLogprobs != null) {
    common.setValueByPath(toObject, ['avgLogprobs'], fromAvgLogprobs);
  }

  const fromFinishReason = common.getValueByPath(fromObject, ['finishReason']);
  if (fromFinishReason != null) {
    common.setValueByPath(toObject, ['finishReason'], fromFinishReason);
  }

  const fromGroundingMetadata = common.getValueByPath(fromObject, [
    'groundingMetadata',
  ]);
  if (fromGroundingMetadata != null) {
    common.setValueByPath(
      toObject,
      ['groundingMetadata'],
      fromGroundingMetadata,
    );
  }

  const fromIndex = common.getValueByPath(fromObject, ['index']);
  if (fromIndex != null) {
    common.setValueByPath(toObject, ['index'], fromIndex);
  }

  const fromLogprobsResult = common.getValueByPath(fromObject, [
    'logprobsResult',
  ]);
  if (fromLogprobsResult != null) {
    common.setValueByPath(toObject, ['logprobsResult'], fromLogprobsResult);
  }

  const fromSafetyRatings = common.getValueByPath(fromObject, [
    'safetyRatings',
  ]);
  if (fromSafetyRatings != null) {
    common.setValueByPath(toObject, ['safetyRatings'], fromSafetyRatings);
  }

  return toObject;
}

function candidateFromVertex(
  apiClient: ApiClient,
  fromObject: types.Candidate,
): Record<string, unknown> {
  const toObject: Record<string, unknown> = {};

  const fromContent = common.getValueByPath(fromObject, ['content']);
  if (fromContent != null) {
    common.setValueByPath(
      toObject,
      ['content'],
      contentFromVertex(apiClient, fromContent),
    );
  }

  const fromCitationMetadata = common.getValueByPath(fromObject, [
    'citationMetadata',
  ]);
  if (fromCitationMetadata != null) {
    common.setValueByPath(
      toObject,
      ['citationMetadata'],
      citationMetadataFromVertex(apiClient, fromCitationMetadata),
    );
  }

  const fromFinishMessage = common.getValueByPath(fromObject, [
    'finishMessage',
  ]);
  if (fromFinishMessage != null) {
    common.setValueByPath(toObject, ['finishMessage'], fromFinishMessage);
  }

  const fromAvgLogprobs = common.getValueByPath(fromObject, ['avgLogprobs']);
  if (fromAvgLogprobs != null) {
    common.setValueByPath(toObject, ['avgLogprobs'], fromAvgLogprobs);
  }

  const fromFinishReason = common.getValueByPath(fromObject, ['finishReason']);
  if (fromFinishReason != null) {
    common.setValueByPath(toObject, ['finishReason'], fromFinishReason);
  }

  const fromGroundingMetadata = common.getValueByPath(fromObject, [
    'groundingMetadata',
  ]);
  if (fromGroundingMetadata != null) {
    common.setValueByPath(
      toObject,
      ['groundingMetadata'],
      fromGroundingMetadata,
    );
  }

  const fromIndex = common.getValueByPath(fromObject, ['index']);
  if (fromIndex != null) {
    common.setValueByPath(toObject, ['index'], fromIndex);
  }

  const fromLogprobsResult = common.getValueByPath(fromObject, [
    'logprobsResult',
  ]);
  if (fromLogprobsResult != null) {
    common.setValueByPath(toObject, ['logprobsResult'], fromLogprobsResult);
  }

  const fromSafetyRatings = common.getValueByPath(fromObject, [
    'safetyRatings',
  ]);
  if (fromSafetyRatings != null) {
    common.setValueByPath(toObject, ['safetyRatings'], fromSafetyRatings);
  }

  return toObject;
}

function generateContentResponseFromMldev(
  apiClient: ApiClient,
  fromObject: types.GenerateContentResponse,
): Record<string, unknown> {
  const toObject: Record<string, unknown> = {};

  const fromCandidates = common.getValueByPath(fromObject, ['candidates']);
  if (fromCandidates != null) {
    if (Array.isArray(fromCandidates)) {
      common.setValueByPath(
        toObject,
        ['candidates'],
        fromCandidates.map((item) => {
          return candidateFromMldev(apiClient, item);
        }),
      );
    } else {
      common.setValueByPath(toObject, ['candidates'], fromCandidates);
    }
  }

  const fromModelVersion = common.getValueByPath(fromObject, ['modelVersion']);
  if (fromModelVersion != null) {
    common.setValueByPath(toObject, ['modelVersion'], fromModelVersion);
  }

  const fromPromptFeedback = common.getValueByPath(fromObject, [
    'promptFeedback',
  ]);
  if (fromPromptFeedback != null) {
    common.setValueByPath(toObject, ['promptFeedback'], fromPromptFeedback);
  }

  const fromUsageMetadata = common.getValueByPath(fromObject, [
    'usageMetadata',
  ]);
  if (fromUsageMetadata != null) {
    common.setValueByPath(toObject, ['usageMetadata'], fromUsageMetadata);
  }

  return toObject;
}

function generateContentResponseFromVertex(
  apiClient: ApiClient,
  fromObject: types.GenerateContentResponse,
): Record<string, unknown> {
  const toObject: Record<string, unknown> = {};

  const fromCandidates = common.getValueByPath(fromObject, ['candidates']);
  if (fromCandidates != null) {
    if (Array.isArray(fromCandidates)) {
      common.setValueByPath(
        toObject,
        ['candidates'],
        fromCandidates.map((item) => {
          return candidateFromVertex(apiClient, item);
        }),
      );
    } else {
      common.setValueByPath(toObject, ['candidates'], fromCandidates);
    }
  }

  const fromCreateTime = common.getValueByPath(fromObject, ['createTime']);
  if (fromCreateTime != null) {
    common.setValueByPath(toObject, ['createTime'], fromCreateTime);
  }

  const fromResponseId = common.getValueByPath(fromObject, ['responseId']);
  if (fromResponseId != null) {
    common.setValueByPath(toObject, ['responseId'], fromResponseId);
  }

  const fromModelVersion = common.getValueByPath(fromObject, ['modelVersion']);
  if (fromModelVersion != null) {
    common.setValueByPath(toObject, ['modelVersion'], fromModelVersion);
  }

  const fromPromptFeedback = common.getValueByPath(fromObject, [
    'promptFeedback',
  ]);
  if (fromPromptFeedback != null) {
    common.setValueByPath(toObject, ['promptFeedback'], fromPromptFeedback);
  }

  const fromUsageMetadata = common.getValueByPath(fromObject, [
    'usageMetadata',
  ]);
  if (fromUsageMetadata != null) {
    common.setValueByPath(toObject, ['usageMetadata'], fromUsageMetadata);
  }

  return toObject;
}

function contentEmbeddingStatisticsFromMldev(): Record<string, unknown> {
  const toObject: Record<string, unknown> = {};

  return toObject;
}

function contentEmbeddingStatisticsFromVertex(
  apiClient: ApiClient,
  fromObject: types.ContentEmbeddingStatistics,
): Record<string, unknown> {
  const toObject: Record<string, unknown> = {};

  const fromTruncated = common.getValueByPath(fromObject, ['truncated']);
  if (fromTruncated != null) {
    common.setValueByPath(toObject, ['truncated'], fromTruncated);
  }

  const fromTokenCount = common.getValueByPath(fromObject, ['token_count']);
  if (fromTokenCount != null) {
    common.setValueByPath(toObject, ['tokenCount'], fromTokenCount);
  }

  return toObject;
}

function contentEmbeddingFromMldev(
  apiClient: ApiClient,
  fromObject: types.ContentEmbedding,
): Record<string, unknown> {
  const toObject: Record<string, unknown> = {};

  const fromValues = common.getValueByPath(fromObject, ['values']);
  if (fromValues != null) {
    common.setValueByPath(toObject, ['values'], fromValues);
  }

  return toObject;
}

function contentEmbeddingFromVertex(
  apiClient: ApiClient,
  fromObject: types.ContentEmbedding,
): Record<string, unknown> {
  const toObject: Record<string, unknown> = {};

  const fromValues = common.getValueByPath(fromObject, ['values']);
  if (fromValues != null) {
    common.setValueByPath(toObject, ['values'], fromValues);
  }

  const fromStatistics = common.getValueByPath(fromObject, ['statistics']);
  if (fromStatistics != null) {
    common.setValueByPath(
      toObject,
      ['statistics'],
      contentEmbeddingStatisticsFromVertex(apiClient, fromStatistics),
    );
  }

  return toObject;
}

function embedContentMetadataFromMldev(): Record<string, unknown> {
  const toObject: Record<string, unknown> = {};

  return toObject;
}

function embedContentMetadataFromVertex(
  apiClient: ApiClient,
  fromObject: types.EmbedContentMetadata,
): Record<string, unknown> {
  const toObject: Record<string, unknown> = {};

  const fromBillableCharacterCount = common.getValueByPath(fromObject, [
    'billableCharacterCount',
  ]);
  if (fromBillableCharacterCount != null) {
    common.setValueByPath(
      toObject,
      ['billableCharacterCount'],
      fromBillableCharacterCount,
    );
  }

  return toObject;
}

function embedContentResponseFromMldev(
  apiClient: ApiClient,
  fromObject: types.EmbedContentResponse,
): Record<string, unknown> {
  const toObject: Record<string, unknown> = {};

  const fromEmbeddings = common.getValueByPath(fromObject, ['embeddings']);
  if (fromEmbeddings != null) {
    if (Array.isArray(fromEmbeddings)) {
      common.setValueByPath(
        toObject,
        ['embeddings'],
        fromEmbeddings.map((item) => {
          return contentEmbeddingFromMldev(apiClient, item);
        }),
      );
    } else {
      common.setValueByPath(toObject, ['embeddings'], fromEmbeddings);
    }
  }

  const fromMetadata = common.getValueByPath(fromObject, ['metadata']);
  if (fromMetadata != null) {
    common.setValueByPath(
      toObject,
      ['metadata'],
      embedContentMetadataFromMldev(),
    );
  }

  return toObject;
}

function embedContentResponseFromVertex(
  apiClient: ApiClient,
  fromObject: types.EmbedContentResponse,
): Record<string, unknown> {
  const toObject: Record<string, unknown> = {};

  const fromEmbeddings = common.getValueByPath(fromObject, [
    'predictions[]',
    'embeddings',
  ]);
  if (fromEmbeddings != null) {
    if (Array.isArray(fromEmbeddings)) {
      common.setValueByPath(
        toObject,
        ['embeddings'],
        fromEmbeddings.map((item) => {
          return contentEmbeddingFromVertex(apiClient, item);
        }),
      );
    } else {
      common.setValueByPath(toObject, ['embeddings'], fromEmbeddings);
    }
  }

  const fromMetadata = common.getValueByPath(fromObject, ['metadata']);
  if (fromMetadata != null) {
    common.setValueByPath(
      toObject,
      ['metadata'],
      embedContentMetadataFromVertex(apiClient, fromMetadata),
    );
  }

  return toObject;
}

function imageFromMldev(
  apiClient: ApiClient,
  fromObject: types.Image,
): Record<string, unknown> {
  const toObject: Record<string, unknown> = {};

  const fromImageBytes = common.getValueByPath(fromObject, [
    'bytesBase64Encoded',
  ]);
  if (fromImageBytes != null) {
    common.setValueByPath(
      toObject,
      ['imageBytes'],
      t.tBytes(apiClient, fromImageBytes),
    );
  }

  const fromMimeType = common.getValueByPath(fromObject, ['mimeType']);
  if (fromMimeType != null) {
    common.setValueByPath(toObject, ['mimeType'], fromMimeType);
  }

  return toObject;
}

function imageFromVertex(
  apiClient: ApiClient,
  fromObject: types.Image,
): Record<string, unknown> {
  const toObject: Record<string, unknown> = {};

  const fromGcsUri = common.getValueByPath(fromObject, ['gcsUri']);
  if (fromGcsUri != null) {
    common.setValueByPath(toObject, ['gcsUri'], fromGcsUri);
  }

  const fromImageBytes = common.getValueByPath(fromObject, [
    'bytesBase64Encoded',
  ]);
  if (fromImageBytes != null) {
    common.setValueByPath(
      toObject,
      ['imageBytes'],
      t.tBytes(apiClient, fromImageBytes),
    );
  }

  const fromMimeType = common.getValueByPath(fromObject, ['mimeType']);
  if (fromMimeType != null) {
    common.setValueByPath(toObject, ['mimeType'], fromMimeType);
  }

  return toObject;
}

function safetyAttributesFromMldev(
  apiClient: ApiClient,
  fromObject: types.SafetyAttributes,
): Record<string, unknown> {
  const toObject: Record<string, unknown> = {};

  const fromCategories = common.getValueByPath(fromObject, [
    'safetyAttributes',
    'categories',
  ]);
  if (fromCategories != null) {
    common.setValueByPath(toObject, ['categories'], fromCategories);
  }

  const fromScores = common.getValueByPath(fromObject, [
    'safetyAttributes',
    'scores',
  ]);
  if (fromScores != null) {
    common.setValueByPath(toObject, ['scores'], fromScores);
  }

  return toObject;
}

function safetyAttributesFromVertex(
  apiClient: ApiClient,
  fromObject: types.SafetyAttributes,
): Record<string, unknown> {
  const toObject: Record<string, unknown> = {};

  const fromCategories = common.getValueByPath(fromObject, [
    'safetyAttributes',
    'categories',
  ]);
  if (fromCategories != null) {
    common.setValueByPath(toObject, ['categories'], fromCategories);
  }

  const fromScores = common.getValueByPath(fromObject, [
    'safetyAttributes',
    'scores',
  ]);
  if (fromScores != null) {
    common.setValueByPath(toObject, ['scores'], fromScores);
  }

  return toObject;
}

function generatedImageFromMldev(
  apiClient: ApiClient,
  fromObject: types.GeneratedImage,
): Record<string, unknown> {
  const toObject: Record<string, unknown> = {};

  const fromImage = common.getValueByPath(fromObject, ['_self']);
  if (fromImage != null) {
    common.setValueByPath(
      toObject,
      ['image'],
      imageFromMldev(apiClient, fromImage),
    );
  }

  const fromRaiFilteredReason = common.getValueByPath(fromObject, [
    'raiFilteredReason',
  ]);
  if (fromRaiFilteredReason != null) {
    common.setValueByPath(
      toObject,
      ['raiFilteredReason'],
      fromRaiFilteredReason,
    );
  }

  const fromSafetyAttributes = common.getValueByPath(fromObject, ['_self']);
  if (fromSafetyAttributes != null) {
    common.setValueByPath(
      toObject,
      ['safetyAttributes'],
      safetyAttributesFromMldev(apiClient, fromSafetyAttributes),
    );
  }

  return toObject;
}

function generatedImageFromVertex(
  apiClient: ApiClient,
  fromObject: types.GeneratedImage,
): Record<string, unknown> {
  const toObject: Record<string, unknown> = {};

  const fromImage = common.getValueByPath(fromObject, ['_self']);
  if (fromImage != null) {
    common.setValueByPath(
      toObject,
      ['image'],
      imageFromVertex(apiClient, fromImage),
    );
  }

  const fromRaiFilteredReason = common.getValueByPath(fromObject, [
    'raiFilteredReason',
  ]);
  if (fromRaiFilteredReason != null) {
    common.setValueByPath(
      toObject,
      ['raiFilteredReason'],
      fromRaiFilteredReason,
    );
  }

  const fromSafetyAttributes = common.getValueByPath(fromObject, ['_self']);
  if (fromSafetyAttributes != null) {
    common.setValueByPath(
      toObject,
      ['safetyAttributes'],
      safetyAttributesFromVertex(apiClient, fromSafetyAttributes),
    );
  }

  const fromEnhancedPrompt = common.getValueByPath(fromObject, ['prompt']);
  if (fromEnhancedPrompt != null) {
    common.setValueByPath(toObject, ['enhancedPrompt'], fromEnhancedPrompt);
  }

  return toObject;
}

function generateImagesResponseFromMldev(
  apiClient: ApiClient,
  fromObject: types.GenerateImagesResponse,
): Record<string, unknown> {
  const toObject: Record<string, unknown> = {};

  const fromGeneratedImages = common.getValueByPath(fromObject, [
    'predictions',
  ]);
  if (fromGeneratedImages != null) {
    if (Array.isArray(fromGeneratedImages)) {
      common.setValueByPath(
        toObject,
        ['generatedImages'],
        fromGeneratedImages.map((item) => {
          return generatedImageFromMldev(apiClient, item);
        }),
      );
    } else {
      common.setValueByPath(toObject, ['generatedImages'], fromGeneratedImages);
    }
  }

  return toObject;
}

function generateImagesResponseFromVertex(
  apiClient: ApiClient,
  fromObject: types.GenerateImagesResponse,
): Record<string, unknown> {
  const toObject: Record<string, unknown> = {};

  const fromGeneratedImages = common.getValueByPath(fromObject, [
    'predictions',
  ]);
  if (fromGeneratedImages != null) {
    if (Array.isArray(fromGeneratedImages)) {
      common.setValueByPath(
        toObject,
        ['generatedImages'],
        fromGeneratedImages.map((item) => {
          return generatedImageFromVertex(apiClient, item);
        }),
      );
    } else {
      common.setValueByPath(toObject, ['generatedImages'], fromGeneratedImages);
    }
  }

  return toObject;
}

function countTokensResponseFromMldev(
  apiClient: ApiClient,
  fromObject: types.CountTokensResponse,
): Record<string, unknown> {
  const toObject: Record<string, unknown> = {};

  const fromTotalTokens = common.getValueByPath(fromObject, ['totalTokens']);
  if (fromTotalTokens != null) {
    common.setValueByPath(toObject, ['totalTokens'], fromTotalTokens);
  }

  const fromCachedContentTokenCount = common.getValueByPath(fromObject, [
    'cachedContentTokenCount',
  ]);
  if (fromCachedContentTokenCount != null) {
    common.setValueByPath(
      toObject,
      ['cachedContentTokenCount'],
      fromCachedContentTokenCount,
    );
  }

  return toObject;
}

function countTokensResponseFromVertex(
  apiClient: ApiClient,
  fromObject: types.CountTokensResponse,
): Record<string, unknown> {
  const toObject: Record<string, unknown> = {};

  const fromTotalTokens = common.getValueByPath(fromObject, ['totalTokens']);
  if (fromTotalTokens != null) {
    common.setValueByPath(toObject, ['totalTokens'], fromTotalTokens);
  }

  return toObject;
}

function computeTokensResponseFromMldev(
  apiClient: ApiClient,
  fromObject: types.ComputeTokensResponse,
): Record<string, unknown> {
  const toObject: Record<string, unknown> = {};

  const fromTokensInfo = common.getValueByPath(fromObject, ['tokensInfo']);
  if (fromTokensInfo != null) {
    common.setValueByPath(toObject, ['tokensInfo'], fromTokensInfo);
  }

  return toObject;
}

function computeTokensResponseFromVertex(
  apiClient: ApiClient,
  fromObject: types.ComputeTokensResponse,
): Record<string, unknown> {
  const toObject: Record<string, unknown> = {};

  const fromTokensInfo = common.getValueByPath(fromObject, ['tokensInfo']);
  if (fromTokensInfo != null) {
    common.setValueByPath(toObject, ['tokensInfo'], fromTokensInfo);
  }

  return toObject;
}
