/**
 * @license
 * Copyright 2024 Google LLC
 * SPDX-License-Identifier: Apache-2.0
 */

// Code generated by the Google Gen AI SDK generator DO NOT EDIT.

import {ApiClient} from './_api_client';
import * as common from './_common';
import {BaseModule} from './_common';
import * as t from './_transformers';
import {PagedItem, Pager} from './pagers';
import * as types from './types';

function partToMldev(
  apiClient: ApiClient,
  fromObject: any,
  parentObject?: any,
): Record<string, any> {
  let toObject: Record<string, any> = {};

  if (common.getValueByPath(fromObject, ['videoMetadata']) !== undefined) {
    throw new Error('videoMetadata parameter is not supported in Gemini API.');
  }

  let fromThought = common.getValueByPath(fromObject, ['thought']);
  if (fromThought !== undefined) {
    common.setValueByPath(toObject, ['thought'], fromThought);
  }

  let fromCodeExecutionResult = common.getValueByPath(fromObject, [
    'codeExecutionResult',
  ]);
  if (fromCodeExecutionResult !== undefined) {
    common.setValueByPath(
      toObject,
      ['codeExecutionResult'],
      fromCodeExecutionResult,
    );
  }

  let fromExecutableCode = common.getValueByPath(fromObject, [
    'executableCode',
  ]);
  if (fromExecutableCode !== undefined) {
    common.setValueByPath(toObject, ['executableCode'], fromExecutableCode);
  }

  let fromFileData = common.getValueByPath(fromObject, ['fileData']);
  if (fromFileData !== undefined) {
    common.setValueByPath(toObject, ['fileData'], fromFileData);
  }

  let fromFunctionCall = common.getValueByPath(fromObject, ['functionCall']);
  if (fromFunctionCall !== undefined) {
    common.setValueByPath(toObject, ['functionCall'], fromFunctionCall);
  }

  let fromFunctionResponse = common.getValueByPath(fromObject, [
    'functionResponse',
  ]);
  if (fromFunctionResponse !== undefined) {
    common.setValueByPath(toObject, ['functionResponse'], fromFunctionResponse);
  }

  let fromInlineData = common.getValueByPath(fromObject, ['inlineData']);
  if (fromInlineData !== undefined) {
    common.setValueByPath(toObject, ['inlineData'], fromInlineData);
  }

  let fromText = common.getValueByPath(fromObject, ['text']);
  if (fromText !== undefined) {
    common.setValueByPath(toObject, ['text'], fromText);
  }

  return toObject;
}

function partToVertex(
  apiClient: ApiClient,
  fromObject: any,
  parentObject?: any,
): Record<string, any> {
  let toObject: Record<string, any> = {};

  let fromVideoMetadata = common.getValueByPath(fromObject, ['videoMetadata']);
  if (fromVideoMetadata !== undefined) {
    common.setValueByPath(toObject, ['videoMetadata'], fromVideoMetadata);
  }

  let fromThought = common.getValueByPath(fromObject, ['thought']);
  if (fromThought !== undefined) {
    common.setValueByPath(toObject, ['thought'], fromThought);
  }

  let fromCodeExecutionResult = common.getValueByPath(fromObject, [
    'codeExecutionResult',
  ]);
  if (fromCodeExecutionResult !== undefined) {
    common.setValueByPath(
      toObject,
      ['codeExecutionResult'],
      fromCodeExecutionResult,
    );
  }

  let fromExecutableCode = common.getValueByPath(fromObject, [
    'executableCode',
  ]);
  if (fromExecutableCode !== undefined) {
    common.setValueByPath(toObject, ['executableCode'], fromExecutableCode);
  }

  let fromFileData = common.getValueByPath(fromObject, ['fileData']);
  if (fromFileData !== undefined) {
    common.setValueByPath(toObject, ['fileData'], fromFileData);
  }

  let fromFunctionCall = common.getValueByPath(fromObject, ['functionCall']);
  if (fromFunctionCall !== undefined) {
    common.setValueByPath(toObject, ['functionCall'], fromFunctionCall);
  }

  let fromFunctionResponse = common.getValueByPath(fromObject, [
    'functionResponse',
  ]);
  if (fromFunctionResponse !== undefined) {
    common.setValueByPath(toObject, ['functionResponse'], fromFunctionResponse);
  }

  let fromInlineData = common.getValueByPath(fromObject, ['inlineData']);
  if (fromInlineData !== undefined) {
    common.setValueByPath(toObject, ['inlineData'], fromInlineData);
  }

  let fromText = common.getValueByPath(fromObject, ['text']);
  if (fromText !== undefined) {
    common.setValueByPath(toObject, ['text'], fromText);
  }

  return toObject;
}

export function contentToMldev(
  apiClient: ApiClient,
  fromObject: any,
  parentObject?: any,
): Record<string, any> {
  let toObject: Record<string, any> = {};

  let fromParts = common.getValueByPath(fromObject, ['parts']);
  if (fromParts !== undefined) {
    common.setValueByPath(
      toObject,
      ['parts'],
      fromParts!.map((item: any) => {
        return partToMldev(apiClient, item, toObject);
      }),
    );
  }

  let fromRole = common.getValueByPath(fromObject, ['role']);
  if (fromRole !== undefined) {
    common.setValueByPath(toObject, ['role'], fromRole);
  }

  return toObject;
}

export function contentToVertex(
  apiClient: ApiClient,
  fromObject: any,
  parentObject?: any,
): Record<string, any> {
  let toObject: Record<string, any> = {};

  let fromParts = common.getValueByPath(fromObject, ['parts']);
  if (fromParts !== undefined) {
    common.setValueByPath(
      toObject,
      ['parts'],
      fromParts!.map((item: any) => {
        return partToVertex(apiClient, item, toObject);
      }),
    );
  }

  let fromRole = common.getValueByPath(fromObject, ['role']);
  if (fromRole !== undefined) {
    common.setValueByPath(toObject, ['role'], fromRole);
  }

  return toObject;
}

function schemaToMldev(
  apiClient: ApiClient,
  fromObject: any,
  parentObject?: any,
): Record<string, any> {
  let toObject: Record<string, any> = {};

  if (common.getValueByPath(fromObject, ['minItems']) !== undefined) {
    throw new Error('minItems parameter is not supported in Gemini API.');
  }

  if (common.getValueByPath(fromObject, ['example']) !== undefined) {
    throw new Error('example parameter is not supported in Gemini API.');
  }

  if (common.getValueByPath(fromObject, ['propertyOrdering']) !== undefined) {
    throw new Error(
      'propertyOrdering parameter is not supported in Gemini API.',
    );
  }

  if (common.getValueByPath(fromObject, ['pattern']) !== undefined) {
    throw new Error('pattern parameter is not supported in Gemini API.');
  }

  if (common.getValueByPath(fromObject, ['minimum']) !== undefined) {
    throw new Error('minimum parameter is not supported in Gemini API.');
  }

  if (common.getValueByPath(fromObject, ['default']) !== undefined) {
    throw new Error('default parameter is not supported in Gemini API.');
  }

  if (common.getValueByPath(fromObject, ['anyOf']) !== undefined) {
    throw new Error('anyOf parameter is not supported in Gemini API.');
  }

  if (common.getValueByPath(fromObject, ['maxLength']) !== undefined) {
    throw new Error('maxLength parameter is not supported in Gemini API.');
  }

  if (common.getValueByPath(fromObject, ['title']) !== undefined) {
    throw new Error('title parameter is not supported in Gemini API.');
  }

  if (common.getValueByPath(fromObject, ['minLength']) !== undefined) {
    throw new Error('minLength parameter is not supported in Gemini API.');
  }

  if (common.getValueByPath(fromObject, ['minProperties']) !== undefined) {
    throw new Error('minProperties parameter is not supported in Gemini API.');
  }

  if (common.getValueByPath(fromObject, ['maxItems']) !== undefined) {
    throw new Error('maxItems parameter is not supported in Gemini API.');
  }

  if (common.getValueByPath(fromObject, ['maximum']) !== undefined) {
    throw new Error('maximum parameter is not supported in Gemini API.');
  }

  if (common.getValueByPath(fromObject, ['nullable']) !== undefined) {
    throw new Error('nullable parameter is not supported in Gemini API.');
  }

  if (common.getValueByPath(fromObject, ['maxProperties']) !== undefined) {
    throw new Error('maxProperties parameter is not supported in Gemini API.');
  }

  let fromType = common.getValueByPath(fromObject, ['type']);
  if (fromType !== undefined) {
    common.setValueByPath(toObject, ['type'], fromType);
  }

  let fromDescription = common.getValueByPath(fromObject, ['description']);
  if (fromDescription !== undefined) {
    common.setValueByPath(toObject, ['description'], fromDescription);
  }

  let fromEnum = common.getValueByPath(fromObject, ['enum']);
  if (fromEnum !== undefined) {
    common.setValueByPath(toObject, ['enum'], fromEnum);
  }

  let fromFormat = common.getValueByPath(fromObject, ['format']);
  if (fromFormat !== undefined) {
    common.setValueByPath(toObject, ['format'], fromFormat);
  }

  let fromItems = common.getValueByPath(fromObject, ['items']);
  if (fromItems !== undefined) {
    common.setValueByPath(toObject, ['items'], fromItems);
  }

  let fromProperties = common.getValueByPath(fromObject, ['properties']);
  if (fromProperties !== undefined) {
    common.setValueByPath(toObject, ['properties'], fromProperties);
  }

  let fromRequired = common.getValueByPath(fromObject, ['required']);
  if (fromRequired !== undefined) {
    common.setValueByPath(toObject, ['required'], fromRequired);
  }

  return toObject;
}

function schemaToVertex(
  apiClient: ApiClient,
  fromObject: any,
  parentObject?: any,
): Record<string, any> {
  let toObject: Record<string, any> = {};

  let fromMinItems = common.getValueByPath(fromObject, ['minItems']);
  if (fromMinItems !== undefined) {
    common.setValueByPath(toObject, ['minItems'], fromMinItems);
  }

  let fromExample = common.getValueByPath(fromObject, ['example']);
  if (fromExample !== undefined) {
    common.setValueByPath(toObject, ['example'], fromExample);
  }

  let fromPropertyOrdering = common.getValueByPath(fromObject, [
    'propertyOrdering',
  ]);
  if (fromPropertyOrdering !== undefined) {
    common.setValueByPath(toObject, ['propertyOrdering'], fromPropertyOrdering);
  }

  let fromPattern = common.getValueByPath(fromObject, ['pattern']);
  if (fromPattern !== undefined) {
    common.setValueByPath(toObject, ['pattern'], fromPattern);
  }

  let fromMinimum = common.getValueByPath(fromObject, ['minimum']);
  if (fromMinimum !== undefined) {
    common.setValueByPath(toObject, ['minimum'], fromMinimum);
  }

  let fromDefault = common.getValueByPath(fromObject, ['default']);
  if (fromDefault !== undefined) {
    common.setValueByPath(toObject, ['default'], fromDefault);
  }

  let fromAnyOf = common.getValueByPath(fromObject, ['anyOf']);
  if (fromAnyOf !== undefined) {
    common.setValueByPath(toObject, ['anyOf'], fromAnyOf);
  }

  let fromMaxLength = common.getValueByPath(fromObject, ['maxLength']);
  if (fromMaxLength !== undefined) {
    common.setValueByPath(toObject, ['maxLength'], fromMaxLength);
  }

  let fromTitle = common.getValueByPath(fromObject, ['title']);
  if (fromTitle !== undefined) {
    common.setValueByPath(toObject, ['title'], fromTitle);
  }

  let fromMinLength = common.getValueByPath(fromObject, ['minLength']);
  if (fromMinLength !== undefined) {
    common.setValueByPath(toObject, ['minLength'], fromMinLength);
  }

  let fromMinProperties = common.getValueByPath(fromObject, ['minProperties']);
  if (fromMinProperties !== undefined) {
    common.setValueByPath(toObject, ['minProperties'], fromMinProperties);
  }

  let fromMaxItems = common.getValueByPath(fromObject, ['maxItems']);
  if (fromMaxItems !== undefined) {
    common.setValueByPath(toObject, ['maxItems'], fromMaxItems);
  }

  let fromMaximum = common.getValueByPath(fromObject, ['maximum']);
  if (fromMaximum !== undefined) {
    common.setValueByPath(toObject, ['maximum'], fromMaximum);
  }

  let fromNullable = common.getValueByPath(fromObject, ['nullable']);
  if (fromNullable !== undefined) {
    common.setValueByPath(toObject, ['nullable'], fromNullable);
  }

  let fromMaxProperties = common.getValueByPath(fromObject, ['maxProperties']);
  if (fromMaxProperties !== undefined) {
    common.setValueByPath(toObject, ['maxProperties'], fromMaxProperties);
  }

  let fromType = common.getValueByPath(fromObject, ['type']);
  if (fromType !== undefined) {
    common.setValueByPath(toObject, ['type'], fromType);
  }

  let fromDescription = common.getValueByPath(fromObject, ['description']);
  if (fromDescription !== undefined) {
    common.setValueByPath(toObject, ['description'], fromDescription);
  }

  let fromEnum = common.getValueByPath(fromObject, ['enum']);
  if (fromEnum !== undefined) {
    common.setValueByPath(toObject, ['enum'], fromEnum);
  }

  let fromFormat = common.getValueByPath(fromObject, ['format']);
  if (fromFormat !== undefined) {
    common.setValueByPath(toObject, ['format'], fromFormat);
  }

  let fromItems = common.getValueByPath(fromObject, ['items']);
  if (fromItems !== undefined) {
    common.setValueByPath(toObject, ['items'], fromItems);
  }

  let fromProperties = common.getValueByPath(fromObject, ['properties']);
  if (fromProperties !== undefined) {
    common.setValueByPath(toObject, ['properties'], fromProperties);
  }

  let fromRequired = common.getValueByPath(fromObject, ['required']);
  if (fromRequired !== undefined) {
    common.setValueByPath(toObject, ['required'], fromRequired);
  }

  return toObject;
}

function safetySettingToMldev(
  apiClient: ApiClient,
  fromObject: any,
  parentObject?: any,
): Record<string, any> {
  let toObject: Record<string, any> = {};

  if (common.getValueByPath(fromObject, ['method']) !== undefined) {
    throw new Error('method parameter is not supported in Gemini API.');
  }

  let fromCategory = common.getValueByPath(fromObject, ['category']);
  if (fromCategory !== undefined) {
    common.setValueByPath(toObject, ['category'], fromCategory);
  }

  let fromThreshold = common.getValueByPath(fromObject, ['threshold']);
  if (fromThreshold !== undefined) {
    common.setValueByPath(toObject, ['threshold'], fromThreshold);
  }

  return toObject;
}

function safetySettingToVertex(
  apiClient: ApiClient,
  fromObject: any,
  parentObject?: any,
): Record<string, any> {
  let toObject: Record<string, any> = {};

  let fromMethod = common.getValueByPath(fromObject, ['method']);
  if (fromMethod !== undefined) {
    common.setValueByPath(toObject, ['method'], fromMethod);
  }

  let fromCategory = common.getValueByPath(fromObject, ['category']);
  if (fromCategory !== undefined) {
    common.setValueByPath(toObject, ['category'], fromCategory);
  }

  let fromThreshold = common.getValueByPath(fromObject, ['threshold']);
  if (fromThreshold !== undefined) {
    common.setValueByPath(toObject, ['threshold'], fromThreshold);
  }

  return toObject;
}

function functionDeclarationToMldev(
  apiClient: ApiClient,
  fromObject: any,
  parentObject?: any,
): Record<string, any> {
  let toObject: Record<string, any> = {};

  if (common.getValueByPath(fromObject, ['response']) !== undefined) {
    throw new Error('response parameter is not supported in Gemini API.');
  }

  let fromDescription = common.getValueByPath(fromObject, ['description']);
  if (fromDescription !== undefined) {
    common.setValueByPath(toObject, ['description'], fromDescription);
  }

  let fromName = common.getValueByPath(fromObject, ['name']);
  if (fromName !== undefined) {
    common.setValueByPath(toObject, ['name'], fromName);
  }

  let fromParameters = common.getValueByPath(fromObject, ['parameters']);
  if (fromParameters !== undefined) {
    common.setValueByPath(toObject, ['parameters'], fromParameters);
  }

  return toObject;
}

function functionDeclarationToVertex(
  apiClient: ApiClient,
  fromObject: any,
  parentObject?: any,
): Record<string, any> {
  let toObject: Record<string, any> = {};

  let fromResponse = common.getValueByPath(fromObject, ['response']);
  if (fromResponse !== undefined) {
    common.setValueByPath(
      toObject,
      ['response'],
      schemaToVertex(apiClient, fromResponse, toObject),
    );
  }

  let fromDescription = common.getValueByPath(fromObject, ['description']);
  if (fromDescription !== undefined) {
    common.setValueByPath(toObject, ['description'], fromDescription);
  }

  let fromName = common.getValueByPath(fromObject, ['name']);
  if (fromName !== undefined) {
    common.setValueByPath(toObject, ['name'], fromName);
  }

  let fromParameters = common.getValueByPath(fromObject, ['parameters']);
  if (fromParameters !== undefined) {
    common.setValueByPath(toObject, ['parameters'], fromParameters);
  }

  return toObject;
}

function googleSearchToMldev(
  apiClient: ApiClient,
  fromObject: any,
  parentObject?: any,
): Record<string, any> {
  let toObject: Record<string, any> = {};

  return toObject;
}

function googleSearchToVertex(
  apiClient: ApiClient,
  fromObject: any,
  parentObject?: any,
): Record<string, any> {
  let toObject: Record<string, any> = {};

  return toObject;
}

function dynamicRetrievalConfigToMldev(
  apiClient: ApiClient,
  fromObject: any,
  parentObject?: any,
): Record<string, any> {
  let toObject: Record<string, any> = {};

  let fromMode = common.getValueByPath(fromObject, ['mode']);
  if (fromMode !== undefined) {
    common.setValueByPath(toObject, ['mode'], fromMode);
  }

  let fromDynamicThreshold = common.getValueByPath(fromObject, [
    'dynamicThreshold',
  ]);
  if (fromDynamicThreshold !== undefined) {
    common.setValueByPath(toObject, ['dynamicThreshold'], fromDynamicThreshold);
  }

  return toObject;
}

function dynamicRetrievalConfigToVertex(
  apiClient: ApiClient,
  fromObject: any,
  parentObject?: any,
): Record<string, any> {
  let toObject: Record<string, any> = {};

  let fromMode = common.getValueByPath(fromObject, ['mode']);
  if (fromMode !== undefined) {
    common.setValueByPath(toObject, ['mode'], fromMode);
  }

  let fromDynamicThreshold = common.getValueByPath(fromObject, [
    'dynamicThreshold',
  ]);
  if (fromDynamicThreshold !== undefined) {
    common.setValueByPath(toObject, ['dynamicThreshold'], fromDynamicThreshold);
  }

  return toObject;
}

function googleSearchRetrievalToMldev(
  apiClient: ApiClient,
  fromObject: any,
  parentObject?: any,
): Record<string, any> {
  let toObject: Record<string, any> = {};

  let fromDynamicRetrievalConfig = common.getValueByPath(fromObject, [
    'dynamicRetrievalConfig',
  ]);
  if (fromDynamicRetrievalConfig !== undefined) {
    common.setValueByPath(
      toObject,
      ['dynamicRetrievalConfig'],
      dynamicRetrievalConfigToMldev(
        apiClient,
        fromDynamicRetrievalConfig,
        toObject,
      ),
    );
  }

  return toObject;
}

function googleSearchRetrievalToVertex(
  apiClient: ApiClient,
  fromObject: any,
  parentObject?: any,
): Record<string, any> {
  let toObject: Record<string, any> = {};

  let fromDynamicRetrievalConfig = common.getValueByPath(fromObject, [
    'dynamicRetrievalConfig',
  ]);
  if (fromDynamicRetrievalConfig !== undefined) {
    common.setValueByPath(
      toObject,
      ['dynamicRetrievalConfig'],
      dynamicRetrievalConfigToVertex(
        apiClient,
        fromDynamicRetrievalConfig,
        toObject,
      ),
    );
  }

  return toObject;
}

export function toolToMldev(
  apiClient: ApiClient,
  fromObject: any,
  parentObject?: any,
): Record<string, any> {
  let toObject: Record<string, any> = {};

  let fromFunctionDeclarations = common.getValueByPath(fromObject, [
    'functionDeclarations',
  ]);
  if (fromFunctionDeclarations !== undefined) {
    common.setValueByPath(
      toObject,
      ['functionDeclarations'],
      fromFunctionDeclarations!.map((item: any) => {
        return functionDeclarationToMldev(apiClient, item, toObject);
      }),
    );
  }

  if (common.getValueByPath(fromObject, ['retrieval']) !== undefined) {
    throw new Error('retrieval parameter is not supported in Gemini API.');
  }

  let fromGoogleSearch = common.getValueByPath(fromObject, ['googleSearch']);
  if (fromGoogleSearch !== undefined) {
    common.setValueByPath(
      toObject,
      ['googleSearch'],
      googleSearchToMldev(apiClient, fromGoogleSearch, toObject),
    );
  }

  let fromGoogleSearchRetrieval = common.getValueByPath(fromObject, [
    'googleSearchRetrieval',
  ]);
  if (fromGoogleSearchRetrieval !== undefined) {
    common.setValueByPath(
      toObject,
      ['googleSearchRetrieval'],
      googleSearchRetrievalToMldev(
        apiClient,
        fromGoogleSearchRetrieval,
        toObject,
      ),
    );
  }

  let fromCodeExecution = common.getValueByPath(fromObject, ['codeExecution']);
  if (fromCodeExecution !== undefined) {
    common.setValueByPath(toObject, ['codeExecution'], fromCodeExecution);
  }

  return toObject;
}

export function toolToVertex(
  apiClient: ApiClient,
  fromObject: any,
  parentObject?: any,
): Record<string, any> {
  let toObject: Record<string, any> = {};

  let fromFunctionDeclarations = common.getValueByPath(fromObject, [
    'functionDeclarations',
  ]);
  if (fromFunctionDeclarations !== undefined) {
    common.setValueByPath(
      toObject,
      ['functionDeclarations'],
      fromFunctionDeclarations!.map((item: any) => {
        return functionDeclarationToVertex(apiClient, item, toObject);
      }),
    );
  }

  let fromRetrieval = common.getValueByPath(fromObject, ['retrieval']);
  if (fromRetrieval !== undefined) {
    common.setValueByPath(toObject, ['retrieval'], fromRetrieval);
  }

  let fromGoogleSearch = common.getValueByPath(fromObject, ['googleSearch']);
  if (fromGoogleSearch !== undefined) {
    common.setValueByPath(
      toObject,
      ['googleSearch'],
      googleSearchToVertex(apiClient, fromGoogleSearch, toObject),
    );
  }

  let fromGoogleSearchRetrieval = common.getValueByPath(fromObject, [
    'googleSearchRetrieval',
  ]);
  if (fromGoogleSearchRetrieval !== undefined) {
    common.setValueByPath(
      toObject,
      ['googleSearchRetrieval'],
      googleSearchRetrievalToVertex(
        apiClient,
        fromGoogleSearchRetrieval,
        toObject,
      ),
    );
  }

  let fromCodeExecution = common.getValueByPath(fromObject, ['codeExecution']);
  if (fromCodeExecution !== undefined) {
    common.setValueByPath(toObject, ['codeExecution'], fromCodeExecution);
  }

  return toObject;
}

function functionCallingConfigToMldev(
  apiClient: ApiClient,
  fromObject: any,
  parentObject?: any,
): Record<string, any> {
  let toObject: Record<string, any> = {};

  let fromMode = common.getValueByPath(fromObject, ['mode']);
  if (fromMode !== undefined) {
    common.setValueByPath(toObject, ['mode'], fromMode);
  }

  let fromAllowedFunctionNames = common.getValueByPath(fromObject, [
    'allowedFunctionNames',
  ]);
  if (fromAllowedFunctionNames !== undefined) {
    common.setValueByPath(
      toObject,
      ['allowedFunctionNames'],
      fromAllowedFunctionNames,
    );
  }

  return toObject;
}

function functionCallingConfigToVertex(
  apiClient: ApiClient,
  fromObject: any,
  parentObject?: any,
): Record<string, any> {
  let toObject: Record<string, any> = {};

  let fromMode = common.getValueByPath(fromObject, ['mode']);
  if (fromMode !== undefined) {
    common.setValueByPath(toObject, ['mode'], fromMode);
  }

  let fromAllowedFunctionNames = common.getValueByPath(fromObject, [
    'allowedFunctionNames',
  ]);
  if (fromAllowedFunctionNames !== undefined) {
    common.setValueByPath(
      toObject,
      ['allowedFunctionNames'],
      fromAllowedFunctionNames,
    );
  }

  return toObject;
}

function toolConfigToMldev(
  apiClient: ApiClient,
  fromObject: any,
  parentObject?: any,
): Record<string, any> {
  let toObject: Record<string, any> = {};

  let fromFunctionCallingConfig = common.getValueByPath(fromObject, [
    'functionCallingConfig',
  ]);
  if (fromFunctionCallingConfig !== undefined) {
    common.setValueByPath(
      toObject,
      ['functionCallingConfig'],
      functionCallingConfigToMldev(
        apiClient,
        fromFunctionCallingConfig,
        toObject,
      ),
    );
  }

  return toObject;
}

function toolConfigToVertex(
  apiClient: ApiClient,
  fromObject: any,
  parentObject?: any,
): Record<string, any> {
  let toObject: Record<string, any> = {};

  let fromFunctionCallingConfig = common.getValueByPath(fromObject, [
    'functionCallingConfig',
  ]);
  if (fromFunctionCallingConfig !== undefined) {
    common.setValueByPath(
      toObject,
      ['functionCallingConfig'],
      functionCallingConfigToVertex(
        apiClient,
        fromFunctionCallingConfig,
        toObject,
      ),
    );
  }

  return toObject;
}

function prebuiltVoiceConfigToMldev(
  apiClient: ApiClient,
  fromObject: any,
  parentObject?: any,
): Record<string, any> {
  let toObject: Record<string, any> = {};

  let fromVoiceName = common.getValueByPath(fromObject, ['voiceName']);
  if (fromVoiceName !== undefined) {
    common.setValueByPath(toObject, ['voiceName'], fromVoiceName);
  }

  return toObject;
}

function prebuiltVoiceConfigToVertex(
  apiClient: ApiClient,
  fromObject: any,
  parentObject?: any,
): Record<string, any> {
  let toObject: Record<string, any> = {};

  let fromVoiceName = common.getValueByPath(fromObject, ['voiceName']);
  if (fromVoiceName !== undefined) {
    common.setValueByPath(toObject, ['voiceName'], fromVoiceName);
  }

  return toObject;
}

function voiceConfigToMldev(
  apiClient: ApiClient,
  fromObject: any,
  parentObject?: any,
): Record<string, any> {
  let toObject: Record<string, any> = {};

  let fromPrebuiltVoiceConfig = common.getValueByPath(fromObject, [
    'prebuiltVoiceConfig',
  ]);
  if (fromPrebuiltVoiceConfig !== undefined) {
    common.setValueByPath(
      toObject,
      ['prebuiltVoiceConfig'],
      prebuiltVoiceConfigToMldev(apiClient, fromPrebuiltVoiceConfig, toObject),
    );
  }

  return toObject;
}

function voiceConfigToVertex(
  apiClient: ApiClient,
  fromObject: any,
  parentObject?: any,
): Record<string, any> {
  let toObject: Record<string, any> = {};

  let fromPrebuiltVoiceConfig = common.getValueByPath(fromObject, [
    'prebuiltVoiceConfig',
  ]);
  if (fromPrebuiltVoiceConfig !== undefined) {
    common.setValueByPath(
      toObject,
      ['prebuiltVoiceConfig'],
      prebuiltVoiceConfigToVertex(apiClient, fromPrebuiltVoiceConfig, toObject),
    );
  }

  return toObject;
}

function speechConfigToMldev(
  apiClient: ApiClient,
  fromObject: any,
  parentObject?: any,
): Record<string, any> {
  let toObject: Record<string, any> = {};

  let fromVoiceConfig = common.getValueByPath(fromObject, ['voiceConfig']);
  if (fromVoiceConfig !== undefined) {
    common.setValueByPath(
      toObject,
      ['voiceConfig'],
      voiceConfigToMldev(apiClient, fromVoiceConfig, toObject),
    );
  }

  return toObject;
}

function speechConfigToVertex(
  apiClient: ApiClient,
  fromObject: any,
  parentObject?: any,
): Record<string, any> {
  let toObject: Record<string, any> = {};

  let fromVoiceConfig = common.getValueByPath(fromObject, ['voiceConfig']);
  if (fromVoiceConfig !== undefined) {
    common.setValueByPath(
      toObject,
      ['voiceConfig'],
      voiceConfigToVertex(apiClient, fromVoiceConfig, toObject),
    );
  }

  return toObject;
}

function thinkingConfigToMldev(
  apiClient: ApiClient,
  fromObject: any,
  parentObject?: any,
): Record<string, any> {
  let toObject: Record<string, any> = {};

  let fromIncludeThoughts = common.getValueByPath(fromObject, [
    'includeThoughts',
  ]);
  if (fromIncludeThoughts !== undefined) {
    common.setValueByPath(toObject, ['includeThoughts'], fromIncludeThoughts);
  }

  return toObject;
}

function thinkingConfigToVertex(
  apiClient: ApiClient,
  fromObject: any,
  parentObject?: any,
): Record<string, any> {
  let toObject: Record<string, any> = {};

  let fromIncludeThoughts = common.getValueByPath(fromObject, [
    'includeThoughts',
  ]);
  if (fromIncludeThoughts !== undefined) {
    common.setValueByPath(toObject, ['includeThoughts'], fromIncludeThoughts);
  }

  return toObject;
}

function generateContentConfigToMldev(
  apiClient: ApiClient,
  fromObject: any,
  parentObject?: any,
): Record<string, any> {
  let toObject: Record<string, any> = {};

  let fromSystemInstruction = common.getValueByPath(fromObject, [
    'systemInstruction',
  ]);
  if (fromSystemInstruction !== undefined) {
    common.setValueByPath(
      parentObject,
      ['systemInstruction'],
      contentToMldev(
        apiClient,
        t.tContent(apiClient, fromSystemInstruction),
        toObject,
      ),
    );
  }

  let fromTemperature = common.getValueByPath(fromObject, ['temperature']);
  if (fromTemperature !== undefined) {
    common.setValueByPath(toObject, ['temperature'], fromTemperature);
  }

  let fromTopP = common.getValueByPath(fromObject, ['topP']);
  if (fromTopP !== undefined) {
    common.setValueByPath(toObject, ['topP'], fromTopP);
  }

  let fromTopK = common.getValueByPath(fromObject, ['topK']);
  if (fromTopK !== undefined) {
    common.setValueByPath(toObject, ['topK'], fromTopK);
  }

  let fromCandidateCount = common.getValueByPath(fromObject, [
    'candidateCount',
  ]);
  if (fromCandidateCount !== undefined) {
    common.setValueByPath(toObject, ['candidateCount'], fromCandidateCount);
  }

  let fromMaxOutputTokens = common.getValueByPath(fromObject, [
    'maxOutputTokens',
  ]);
  if (fromMaxOutputTokens !== undefined) {
    common.setValueByPath(toObject, ['maxOutputTokens'], fromMaxOutputTokens);
  }

  let fromStopSequences = common.getValueByPath(fromObject, ['stopSequences']);
  if (fromStopSequences !== undefined) {
    common.setValueByPath(toObject, ['stopSequences'], fromStopSequences);
  }

  let fromResponseLogprobs = common.getValueByPath(fromObject, [
    'responseLogprobs',
  ]);
  if (fromResponseLogprobs !== undefined) {
    common.setValueByPath(toObject, ['responseLogprobs'], fromResponseLogprobs);
  }

  let fromLogprobs = common.getValueByPath(fromObject, ['logprobs']);
  if (fromLogprobs !== undefined) {
    common.setValueByPath(toObject, ['logprobs'], fromLogprobs);
  }

  let fromPresencePenalty = common.getValueByPath(fromObject, [
    'presencePenalty',
  ]);
  if (fromPresencePenalty !== undefined) {
    common.setValueByPath(toObject, ['presencePenalty'], fromPresencePenalty);
  }

  let fromFrequencyPenalty = common.getValueByPath(fromObject, [
    'frequencyPenalty',
  ]);
  if (fromFrequencyPenalty !== undefined) {
    common.setValueByPath(toObject, ['frequencyPenalty'], fromFrequencyPenalty);
  }

  let fromSeed = common.getValueByPath(fromObject, ['seed']);
  if (fromSeed !== undefined) {
    common.setValueByPath(toObject, ['seed'], fromSeed);
  }

  let fromResponseMimeType = common.getValueByPath(fromObject, [
    'responseMimeType',
  ]);
  if (fromResponseMimeType !== undefined) {
    common.setValueByPath(toObject, ['responseMimeType'], fromResponseMimeType);
  }

  let fromResponseSchema = common.getValueByPath(fromObject, [
    'responseSchema',
  ]);
  if (fromResponseSchema !== undefined) {
    common.setValueByPath(
      toObject,
      ['responseSchema'],
      schemaToMldev(
        apiClient,
        t.tSchema(apiClient, fromResponseSchema),
        toObject,
      ),
    );
  }

  if (common.getValueByPath(fromObject, ['routingConfig']) !== undefined) {
    throw new Error('routingConfig parameter is not supported in Gemini API.');
  }

  let fromSafetySettings = common.getValueByPath(fromObject, [
    'safetySettings',
  ]);
  if (fromSafetySettings !== undefined) {
    common.setValueByPath(
      parentObject,
      ['safetySettings'],
      fromSafetySettings!.map((item: any) => {
        return safetySettingToMldev(apiClient, item, toObject);
      }),
    );
  }

  let fromTools = common.getValueByPath(fromObject, ['tools']);
  if (fromTools !== undefined) {
    common.setValueByPath(
      parentObject,
      ['tools'],
      t.tTools(
        apiClient,
        t.tTools(apiClient, fromTools)!.map((item: any) => {
          return toolToMldev(apiClient, t.tTool(apiClient, item), toObject);
        }),
      ),
    );
  }

  let fromToolConfig = common.getValueByPath(fromObject, ['toolConfig']);
  if (fromToolConfig !== undefined) {
    common.setValueByPath(
      parentObject,
      ['toolConfig'],
      toolConfigToMldev(apiClient, fromToolConfig, toObject),
    );
  }

  let fromCachedContent = common.getValueByPath(fromObject, ['cachedContent']);
  if (fromCachedContent !== undefined) {
    common.setValueByPath(
      parentObject,
      ['cachedContent'],
      t.tCachedContentName(apiClient, fromCachedContent),
    );
  }

  let fromResponseModalities = common.getValueByPath(fromObject, [
    'responseModalities',
  ]);
  if (fromResponseModalities !== undefined) {
    common.setValueByPath(
      toObject,
      ['responseModalities'],
      fromResponseModalities,
    );
  }

  if (common.getValueByPath(fromObject, ['mediaResolution']) !== undefined) {
    throw new Error(
      'mediaResolution parameter is not supported in Gemini API.',
    );
  }

  let fromSpeechConfig = common.getValueByPath(fromObject, ['speechConfig']);
  if (fromSpeechConfig !== undefined) {
    common.setValueByPath(
      toObject,
      ['speechConfig'],
      speechConfigToMldev(
        apiClient,
        t.tSpeechConfig(apiClient, fromSpeechConfig),
        toObject,
      ),
    );
  }

  if (common.getValueByPath(fromObject, ['audioTimestamp']) !== undefined) {
    throw new Error('audioTimestamp parameter is not supported in Gemini API.');
  }

  let fromThinkingConfig = common.getValueByPath(fromObject, [
    'thinkingConfig',
  ]);
  if (fromThinkingConfig !== undefined) {
    common.setValueByPath(
      toObject,
      ['thinkingConfig'],
      thinkingConfigToMldev(apiClient, fromThinkingConfig, toObject),
    );
  }

  return toObject;
}

function generateContentConfigToVertex(
  apiClient: ApiClient,
  fromObject: any,
  parentObject?: any,
): Record<string, any> {
  let toObject: Record<string, any> = {};

  let fromSystemInstruction = common.getValueByPath(fromObject, [
    'systemInstruction',
  ]);
  if (fromSystemInstruction !== undefined) {
    common.setValueByPath(
      parentObject,
      ['systemInstruction'],
      contentToVertex(
        apiClient,
        t.tContent(apiClient, fromSystemInstruction),
        toObject,
      ),
    );
  }

  let fromTemperature = common.getValueByPath(fromObject, ['temperature']);
  if (fromTemperature !== undefined) {
    common.setValueByPath(toObject, ['temperature'], fromTemperature);
  }

  let fromTopP = common.getValueByPath(fromObject, ['topP']);
  if (fromTopP !== undefined) {
    common.setValueByPath(toObject, ['topP'], fromTopP);
  }

  let fromTopK = common.getValueByPath(fromObject, ['topK']);
  if (fromTopK !== undefined) {
    common.setValueByPath(toObject, ['topK'], fromTopK);
  }

  let fromCandidateCount = common.getValueByPath(fromObject, [
    'candidateCount',
  ]);
  if (fromCandidateCount !== undefined) {
    common.setValueByPath(toObject, ['candidateCount'], fromCandidateCount);
  }

  let fromMaxOutputTokens = common.getValueByPath(fromObject, [
    'maxOutputTokens',
  ]);
  if (fromMaxOutputTokens !== undefined) {
    common.setValueByPath(toObject, ['maxOutputTokens'], fromMaxOutputTokens);
  }

  let fromStopSequences = common.getValueByPath(fromObject, ['stopSequences']);
  if (fromStopSequences !== undefined) {
    common.setValueByPath(toObject, ['stopSequences'], fromStopSequences);
  }

  let fromResponseLogprobs = common.getValueByPath(fromObject, [
    'responseLogprobs',
  ]);
  if (fromResponseLogprobs !== undefined) {
    common.setValueByPath(toObject, ['responseLogprobs'], fromResponseLogprobs);
  }

  let fromLogprobs = common.getValueByPath(fromObject, ['logprobs']);
  if (fromLogprobs !== undefined) {
    common.setValueByPath(toObject, ['logprobs'], fromLogprobs);
  }

  let fromPresencePenalty = common.getValueByPath(fromObject, [
    'presencePenalty',
  ]);
  if (fromPresencePenalty !== undefined) {
    common.setValueByPath(toObject, ['presencePenalty'], fromPresencePenalty);
  }

  let fromFrequencyPenalty = common.getValueByPath(fromObject, [
    'frequencyPenalty',
  ]);
  if (fromFrequencyPenalty !== undefined) {
    common.setValueByPath(toObject, ['frequencyPenalty'], fromFrequencyPenalty);
  }

  let fromSeed = common.getValueByPath(fromObject, ['seed']);
  if (fromSeed !== undefined) {
    common.setValueByPath(toObject, ['seed'], fromSeed);
  }

  let fromResponseMimeType = common.getValueByPath(fromObject, [
    'responseMimeType',
  ]);
  if (fromResponseMimeType !== undefined) {
    common.setValueByPath(toObject, ['responseMimeType'], fromResponseMimeType);
  }

  let fromResponseSchema = common.getValueByPath(fromObject, [
    'responseSchema',
  ]);
  if (fromResponseSchema !== undefined) {
    common.setValueByPath(
      toObject,
      ['responseSchema'],
      schemaToVertex(
        apiClient,
        t.tSchema(apiClient, fromResponseSchema),
        toObject,
      ),
    );
  }

  let fromRoutingConfig = common.getValueByPath(fromObject, ['routingConfig']);
  if (fromRoutingConfig !== undefined) {
    common.setValueByPath(toObject, ['routingConfig'], fromRoutingConfig);
  }

  let fromSafetySettings = common.getValueByPath(fromObject, [
    'safetySettings',
  ]);
  if (fromSafetySettings !== undefined) {
    common.setValueByPath(
      parentObject,
      ['safetySettings'],
      fromSafetySettings!.map((item: any) => {
        return safetySettingToVertex(apiClient, item, toObject);
      }),
    );
  }

  let fromTools = common.getValueByPath(fromObject, ['tools']);
  if (fromTools !== undefined) {
    common.setValueByPath(
      parentObject,
      ['tools'],
      t.tTools(
        apiClient,
        t.tTools(apiClient, fromTools)!.map((item: any) => {
          return toolToVertex(apiClient, t.tTool(apiClient, item), toObject);
        }),
      ),
    );
  }

  let fromToolConfig = common.getValueByPath(fromObject, ['toolConfig']);
  if (fromToolConfig !== undefined) {
    common.setValueByPath(
      parentObject,
      ['toolConfig'],
      toolConfigToVertex(apiClient, fromToolConfig, toObject),
    );
  }

  let fromCachedContent = common.getValueByPath(fromObject, ['cachedContent']);
  if (fromCachedContent !== undefined) {
    common.setValueByPath(
      parentObject,
      ['cachedContent'],
      t.tCachedContentName(apiClient, fromCachedContent),
    );
  }

  let fromResponseModalities = common.getValueByPath(fromObject, [
    'responseModalities',
  ]);
  if (fromResponseModalities !== undefined) {
    common.setValueByPath(
      toObject,
      ['responseModalities'],
      fromResponseModalities,
    );
  }

  let fromMediaResolution = common.getValueByPath(fromObject, [
    'mediaResolution',
  ]);
  if (fromMediaResolution !== undefined) {
    common.setValueByPath(toObject, ['mediaResolution'], fromMediaResolution);
  }

  let fromSpeechConfig = common.getValueByPath(fromObject, ['speechConfig']);
  if (fromSpeechConfig !== undefined) {
    common.setValueByPath(
      toObject,
      ['speechConfig'],
      speechConfigToVertex(
        apiClient,
        t.tSpeechConfig(apiClient, fromSpeechConfig),
        toObject,
      ),
    );
  }

  let fromAudioTimestamp = common.getValueByPath(fromObject, [
    'audioTimestamp',
  ]);
  if (fromAudioTimestamp !== undefined) {
    common.setValueByPath(toObject, ['audioTimestamp'], fromAudioTimestamp);
  }

  let fromThinkingConfig = common.getValueByPath(fromObject, [
    'thinkingConfig',
  ]);
  if (fromThinkingConfig !== undefined) {
    common.setValueByPath(
      toObject,
      ['thinkingConfig'],
      thinkingConfigToVertex(apiClient, fromThinkingConfig, toObject),
    );
  }

  return toObject;
}

function generateContentParametersToMldev(
  apiClient: ApiClient,
  fromObject: any,
  parentObject?: any,
): Record<string, any> {
  let toObject: Record<string, any> = {};

  let fromModel = common.getValueByPath(fromObject, ['model']);
  if (fromModel !== undefined) {
    common.setValueByPath(
      toObject,
      ['_url', 'model'],
      t.tModel(apiClient, fromModel),
    );
  }

  let fromContents = common.getValueByPath(fromObject, ['contents']);
  if (fromContents !== undefined) {
    common.setValueByPath(
      toObject,
      ['contents'],
      t.tContents(
        apiClient,
        t.tContents(apiClient, fromContents)!.map((item: any) => {
          return contentToMldev(apiClient, item, toObject);
        }),
      ),
    );
  }

  let fromConfig = common.getValueByPath(fromObject, ['config']);
  if (fromConfig !== undefined) {
    common.setValueByPath(
      toObject,
      ['generationConfig'],
      generateContentConfigToMldev(apiClient, fromConfig, toObject),
    );
  }

  return toObject;
}

function generateContentParametersToVertex(
  apiClient: ApiClient,
  fromObject: any,
  parentObject?: any,
): Record<string, any> {
  let toObject: Record<string, any> = {};

  let fromModel = common.getValueByPath(fromObject, ['model']);
  if (fromModel !== undefined) {
    common.setValueByPath(
      toObject,
      ['_url', 'model'],
      t.tModel(apiClient, fromModel),
    );
  }

  let fromContents = common.getValueByPath(fromObject, ['contents']);
  if (fromContents !== undefined) {
    common.setValueByPath(
      toObject,
      ['contents'],
      t.tContents(
        apiClient,
        t.tContents(apiClient, fromContents)!.map((item: any) => {
          return contentToVertex(apiClient, item, toObject);
        }),
      ),
    );
  }

  let fromConfig = common.getValueByPath(fromObject, ['config']);
  if (fromConfig !== undefined) {
    common.setValueByPath(
      toObject,
      ['generationConfig'],
      generateContentConfigToVertex(apiClient, fromConfig, toObject),
    );
  }

  return toObject;
}

function embedContentConfigToMldev(
  apiClient: ApiClient,
  fromObject: any,
  parentObject?: any,
): Record<string, any> {
  let toObject: Record<string, any> = {};

  let fromTaskType = common.getValueByPath(fromObject, ['taskType']);
  if (fromTaskType !== undefined) {
    common.setValueByPath(
      parentObject,
      ['requests[]', 'taskType'],
      fromTaskType,
    );
  }

  let fromTitle = common.getValueByPath(fromObject, ['title']);
  if (fromTitle !== undefined) {
    common.setValueByPath(parentObject, ['requests[]', 'title'], fromTitle);
  }

  let fromOutputDimensionality = common.getValueByPath(fromObject, [
    'outputDimensionality',
  ]);
  if (fromOutputDimensionality !== undefined) {
    common.setValueByPath(
      parentObject,
      ['requests[]', 'outputDimensionality'],
      fromOutputDimensionality,
    );
  }

  if (common.getValueByPath(fromObject, ['mimeType']) !== undefined) {
    throw new Error('mimeType parameter is not supported in Gemini API.');
  }

  if (common.getValueByPath(fromObject, ['autoTruncate']) !== undefined) {
    throw new Error('autoTruncate parameter is not supported in Gemini API.');
  }

  return toObject;
}

function embedContentConfigToVertex(
  apiClient: ApiClient,
  fromObject: any,
  parentObject?: any,
): Record<string, any> {
  let toObject: Record<string, any> = {};

  let fromTaskType = common.getValueByPath(fromObject, ['taskType']);
  if (fromTaskType !== undefined) {
    common.setValueByPath(
      parentObject,
      ['instances[]', 'task_type'],
      fromTaskType,
    );
  }

  let fromTitle = common.getValueByPath(fromObject, ['title']);
  if (fromTitle !== undefined) {
    common.setValueByPath(parentObject, ['instances[]', 'title'], fromTitle);
  }

  let fromOutputDimensionality = common.getValueByPath(fromObject, [
    'outputDimensionality',
  ]);
  if (fromOutputDimensionality !== undefined) {
    common.setValueByPath(
      parentObject,
      ['parameters', 'outputDimensionality'],
      fromOutputDimensionality,
    );
  }

  let fromMimeType = common.getValueByPath(fromObject, ['mimeType']);
  if (fromMimeType !== undefined) {
    common.setValueByPath(
      parentObject,
      ['instances[]', 'mimeType'],
      fromMimeType,
    );
  }

  let fromAutoTruncate = common.getValueByPath(fromObject, ['autoTruncate']);
  if (fromAutoTruncate !== undefined) {
    common.setValueByPath(
      parentObject,
      ['parameters', 'autoTruncate'],
      fromAutoTruncate,
    );
  }

  return toObject;
}

function embedContentParametersToMldev(
  apiClient: ApiClient,
  fromObject: any,
  parentObject?: any,
): Record<string, any> {
  let toObject: Record<string, any> = {};

  const fromModelForEmbedContent = common.getValueByPath(fromObject, ['model']);
  if (fromModelForEmbedContent !== undefined) {
    common.setValueByPath(
      toObject,
      ['requests[]', 'model'],
      [t.tModel(apiClient, fromModelForEmbedContent)],
    );
  }

  let fromModel = common.getValueByPath(fromObject, ['model']);
  if (fromModel !== undefined) {
    common.setValueByPath(
      toObject,
      ['_url', 'model'],
      t.tModel(apiClient, fromModel),
    );
  }

  let fromContents = common.getValueByPath(fromObject, ['contents']);
  if (fromContents !== undefined) {
    common.setValueByPath(
      toObject,
      ['requests[]', 'content'],
      t.tContentsForEmbed(apiClient, fromContents),
    );
  }

  let fromConfig = common.getValueByPath(fromObject, ['config']);
  if (fromConfig !== undefined) {
    common.setValueByPath(
      toObject,
      ['config'],
      embedContentConfigToMldev(apiClient, fromConfig, toObject),
    );
  }

  return toObject;
}

function embedContentParametersToVertex(
  apiClient: ApiClient,
  fromObject: any,
  parentObject?: any,
): Record<string, any> {
  let toObject: Record<string, any> = {};

  let fromModel = common.getValueByPath(fromObject, ['model']);
  if (fromModel !== undefined) {
    common.setValueByPath(
      toObject,
      ['_url', 'model'],
      t.tModel(apiClient, fromModel),
    );
  }

  let fromContents = common.getValueByPath(fromObject, ['contents']);
  if (fromContents !== undefined) {
    common.setValueByPath(
      toObject,
      ['instances[]', 'content'],
      t.tContentsForEmbed(apiClient, fromContents),
    );
  }

  let fromConfig = common.getValueByPath(fromObject, ['config']);
  if (fromConfig !== undefined) {
    common.setValueByPath(
      toObject,
      ['config'],
      embedContentConfigToVertex(apiClient, fromConfig, toObject),
    );
  }

  return toObject;
}

function generateImagesConfigToMldev(
  apiClient: ApiClient,
  fromObject: any,
  parentObject?: any,
): Record<string, any> {
  let toObject: Record<string, any> = {};

  if (common.getValueByPath(fromObject, ['outputGcsUri']) !== undefined) {
    throw new Error('outputGcsUri parameter is not supported in Gemini API.');
  }

  let fromNegativePrompt = common.getValueByPath(fromObject, [
    'negativePrompt',
  ]);
  if (fromNegativePrompt !== undefined) {
    common.setValueByPath(
      parentObject,
      ['parameters', 'negativePrompt'],
      fromNegativePrompt,
    );
  }

  let fromNumberOfImages = common.getValueByPath(fromObject, [
    'numberOfImages',
  ]);
  if (fromNumberOfImages !== undefined) {
    common.setValueByPath(
      parentObject,
      ['parameters', 'sampleCount'],
      fromNumberOfImages,
    );
  }

  let fromGuidanceScale = common.getValueByPath(fromObject, ['guidanceScale']);
  if (fromGuidanceScale !== undefined) {
    common.setValueByPath(
      parentObject,
      ['parameters', 'guidanceScale'],
      fromGuidanceScale,
    );
  }

  if (common.getValueByPath(fromObject, ['seed']) !== undefined) {
    throw new Error('seed parameter is not supported in Gemini API.');
  }

  let fromSafetyFilterLevel = common.getValueByPath(fromObject, [
    'safetyFilterLevel',
  ]);
  if (fromSafetyFilterLevel !== undefined) {
    common.setValueByPath(
      parentObject,
      ['parameters', 'safetySetting'],
      fromSafetyFilterLevel,
    );
  }

  let fromPersonGeneration = common.getValueByPath(fromObject, [
    'personGeneration',
  ]);
  if (fromPersonGeneration !== undefined) {
    common.setValueByPath(
      parentObject,
      ['parameters', 'personGeneration'],
      fromPersonGeneration,
    );
  }

  let fromIncludeSafetyAttributes = common.getValueByPath(fromObject, [
    'includeSafetyAttributes',
  ]);
  if (fromIncludeSafetyAttributes !== undefined) {
    common.setValueByPath(
      parentObject,
      ['parameters', 'includeSafetyAttributes'],
      fromIncludeSafetyAttributes,
    );
  }

  let fromIncludeRaiReason = common.getValueByPath(fromObject, [
    'includeRaiReason',
  ]);
  if (fromIncludeRaiReason !== undefined) {
    common.setValueByPath(
      parentObject,
      ['parameters', 'includeRaiReason'],
      fromIncludeRaiReason,
    );
  }

  let fromLanguage = common.getValueByPath(fromObject, ['language']);
  if (fromLanguage !== undefined) {
    common.setValueByPath(
      parentObject,
      ['parameters', 'language'],
      fromLanguage,
    );
  }

  let fromOutputMimeType = common.getValueByPath(fromObject, [
    'outputMimeType',
  ]);
  if (fromOutputMimeType !== undefined) {
    common.setValueByPath(
      parentObject,
      ['parameters', 'outputOptions', 'mimeType'],
      fromOutputMimeType,
    );
  }

  let fromOutputCompressionQuality = common.getValueByPath(fromObject, [
    'outputCompressionQuality',
  ]);
  if (fromOutputCompressionQuality !== undefined) {
    common.setValueByPath(
      parentObject,
      ['parameters', 'outputOptions', 'compressionQuality'],
      fromOutputCompressionQuality,
    );
  }

  if (common.getValueByPath(fromObject, ['addWatermark']) !== undefined) {
    throw new Error('addWatermark parameter is not supported in Gemini API.');
  }

  let fromAspectRatio = common.getValueByPath(fromObject, ['aspectRatio']);
  if (fromAspectRatio !== undefined) {
    common.setValueByPath(
      parentObject,
      ['parameters', 'aspectRatio'],
      fromAspectRatio,
    );
  }

  return toObject;
}

function generateImagesConfigToVertex(
  apiClient: ApiClient,
  fromObject: any,
  parentObject?: any,
): Record<string, any> {
  let toObject: Record<string, any> = {};

  let fromOutputGcsUri = common.getValueByPath(fromObject, ['outputGcsUri']);
  if (fromOutputGcsUri !== undefined) {
    common.setValueByPath(
      parentObject,
      ['parameters', 'storageUri'],
      fromOutputGcsUri,
    );
  }

  let fromNegativePrompt = common.getValueByPath(fromObject, [
    'negativePrompt',
  ]);
  if (fromNegativePrompt !== undefined) {
    common.setValueByPath(
      parentObject,
      ['parameters', 'negativePrompt'],
      fromNegativePrompt,
    );
  }

  let fromNumberOfImages = common.getValueByPath(fromObject, [
    'numberOfImages',
  ]);
  if (fromNumberOfImages !== undefined) {
    common.setValueByPath(
      parentObject,
      ['parameters', 'sampleCount'],
      fromNumberOfImages,
    );
  }

  let fromGuidanceScale = common.getValueByPath(fromObject, ['guidanceScale']);
  if (fromGuidanceScale !== undefined) {
    common.setValueByPath(
      parentObject,
      ['parameters', 'guidanceScale'],
      fromGuidanceScale,
    );
  }

  let fromSeed = common.getValueByPath(fromObject, ['seed']);
  if (fromSeed !== undefined) {
    common.setValueByPath(parentObject, ['parameters', 'seed'], fromSeed);
  }

  let fromSafetyFilterLevel = common.getValueByPath(fromObject, [
    'safetyFilterLevel',
  ]);
  if (fromSafetyFilterLevel !== undefined) {
    common.setValueByPath(
      parentObject,
      ['parameters', 'safetySetting'],
      fromSafetyFilterLevel,
    );
  }

  let fromPersonGeneration = common.getValueByPath(fromObject, [
    'personGeneration',
  ]);
  if (fromPersonGeneration !== undefined) {
    common.setValueByPath(
      parentObject,
      ['parameters', 'personGeneration'],
      fromPersonGeneration,
    );
  }

  let fromIncludeSafetyAttributes = common.getValueByPath(fromObject, [
    'includeSafetyAttributes',
  ]);
  if (fromIncludeSafetyAttributes !== undefined) {
    common.setValueByPath(
      parentObject,
      ['parameters', 'includeSafetyAttributes'],
      fromIncludeSafetyAttributes,
    );
  }

  let fromIncludeRaiReason = common.getValueByPath(fromObject, [
    'includeRaiReason',
  ]);
  if (fromIncludeRaiReason !== undefined) {
    common.setValueByPath(
      parentObject,
      ['parameters', 'includeRaiReason'],
      fromIncludeRaiReason,
    );
  }

  let fromLanguage = common.getValueByPath(fromObject, ['language']);
  if (fromLanguage !== undefined) {
    common.setValueByPath(
      parentObject,
      ['parameters', 'language'],
      fromLanguage,
    );
  }

  let fromOutputMimeType = common.getValueByPath(fromObject, [
    'outputMimeType',
  ]);
  if (fromOutputMimeType !== undefined) {
    common.setValueByPath(
      parentObject,
      ['parameters', 'outputOptions', 'mimeType'],
      fromOutputMimeType,
    );
  }

  let fromOutputCompressionQuality = common.getValueByPath(fromObject, [
    'outputCompressionQuality',
  ]);
  if (fromOutputCompressionQuality !== undefined) {
    common.setValueByPath(
      parentObject,
      ['parameters', 'outputOptions', 'compressionQuality'],
      fromOutputCompressionQuality,
    );
  }

  let fromAddWatermark = common.getValueByPath(fromObject, ['addWatermark']);
  if (fromAddWatermark !== undefined) {
    common.setValueByPath(
      parentObject,
      ['parameters', 'addWatermark'],
      fromAddWatermark,
    );
  }

  let fromAspectRatio = common.getValueByPath(fromObject, ['aspectRatio']);
  if (fromAspectRatio !== undefined) {
    common.setValueByPath(
      parentObject,
      ['parameters', 'aspectRatio'],
      fromAspectRatio,
    );
  }

  return toObject;
}

function generateImagesParametersToMldev(
  apiClient: ApiClient,
  fromObject: any,
  parentObject?: any,
): Record<string, any> {
  let toObject: Record<string, any> = {};

  let fromModel = common.getValueByPath(fromObject, ['model']);
  if (fromModel !== undefined) {
    common.setValueByPath(
      toObject,
      ['_url', 'model'],
      t.tModel(apiClient, fromModel),
    );
  }

  let fromPrompt = common.getValueByPath(fromObject, ['prompt']);
  if (fromPrompt !== undefined) {
    common.setValueByPath(toObject, ['instances', 'prompt'], fromPrompt);
  }

  let fromConfig = common.getValueByPath(fromObject, ['config']);
  if (fromConfig !== undefined) {
    common.setValueByPath(
      toObject,
      ['config'],
      generateImagesConfigToMldev(apiClient, fromConfig, toObject),
    );
  }

  return toObject;
}

function generateImagesParametersToVertex(
  apiClient: ApiClient,
  fromObject: any,
  parentObject?: any,
): Record<string, any> {
  let toObject: Record<string, any> = {};

  let fromModel = common.getValueByPath(fromObject, ['model']);
  if (fromModel !== undefined) {
    common.setValueByPath(
      toObject,
      ['_url', 'model'],
      t.tModel(apiClient, fromModel),
    );
  }

  let fromPrompt = common.getValueByPath(fromObject, ['prompt']);
  if (fromPrompt !== undefined) {
    common.setValueByPath(toObject, ['instances', 'prompt'], fromPrompt);
  }

  let fromConfig = common.getValueByPath(fromObject, ['config']);
  if (fromConfig !== undefined) {
    common.setValueByPath(
      toObject,
      ['config'],
      generateImagesConfigToVertex(apiClient, fromConfig, toObject),
    );
  }

  return toObject;
}

function countTokensConfigToMldev(
  apiClient: ApiClient,
  fromObject: any,
  parentObject?: any,
): Record<string, any> {
  let toObject: Record<string, any> = {};

  let fromSystemInstruction = common.getValueByPath(fromObject, [
    'systemInstruction',
  ]);
  if (fromSystemInstruction !== undefined) {
    common.setValueByPath(
      parentObject,
      ['generateContentRequest', 'systemInstruction'],
      contentToMldev(
        apiClient,
        t.tContent(apiClient, fromSystemInstruction),
        toObject,
      ),
    );
  }

  let fromTools = common.getValueByPath(fromObject, ['tools']);
  if (fromTools !== undefined) {
    common.setValueByPath(
      parentObject,
      ['generateContentRequest', 'tools'],
      fromTools!.map((item: any) => {
        return toolToMldev(apiClient, item, toObject);
      }),
    );
  }

  if (common.getValueByPath(fromObject, ['generationConfig']) !== undefined) {
    throw new Error(
      'generationConfig parameter is not supported in Gemini API.',
    );
  }

  return toObject;
}

function countTokensConfigToVertex(
  apiClient: ApiClient,
  fromObject: any,
  parentObject?: any,
): Record<string, any> {
  let toObject: Record<string, any> = {};

  let fromSystemInstruction = common.getValueByPath(fromObject, [
    'systemInstruction',
  ]);
  if (fromSystemInstruction !== undefined) {
    common.setValueByPath(
      parentObject,
      ['systemInstruction'],
      contentToVertex(
        apiClient,
        t.tContent(apiClient, fromSystemInstruction),
        toObject,
      ),
    );
  }

  let fromTools = common.getValueByPath(fromObject, ['tools']);
  if (fromTools !== undefined) {
    common.setValueByPath(
      parentObject,
      ['tools'],
      fromTools!.map((item: any) => {
        return toolToVertex(apiClient, item, toObject);
      }),
    );
  }

  let fromGenerationConfig = common.getValueByPath(fromObject, [
    'generationConfig',
  ]);
  if (fromGenerationConfig !== undefined) {
    common.setValueByPath(
      parentObject,
      ['generationConfig'],
      fromGenerationConfig,
    );
  }

  return toObject;
}

function countTokensParametersToMldev(
  apiClient: ApiClient,
  fromObject: any,
  parentObject?: any,
): Record<string, any> {
  let toObject: Record<string, any> = {};

  let fromModel = common.getValueByPath(fromObject, ['model']);
  if (fromModel !== undefined) {
    common.setValueByPath(
      toObject,
      ['_url', 'model'],
      t.tModel(apiClient, fromModel),
    );
  }

  let fromContents = common.getValueByPath(fromObject, ['contents']);
  if (fromContents !== undefined) {
    common.setValueByPath(
      toObject,
      ['contents'],
      t.tContents(
        apiClient,
        t.tContents(apiClient, fromContents)!.map((item: any) => {
          return contentToMldev(apiClient, item, toObject);
        }),
      ),
    );
  }

  let fromConfig = common.getValueByPath(fromObject, ['config']);
  if (fromConfig !== undefined) {
    common.setValueByPath(
      toObject,
      ['config'],
      countTokensConfigToMldev(apiClient, fromConfig, toObject),
    );
  }

  return toObject;
}

function countTokensParametersToVertex(
  apiClient: ApiClient,
  fromObject: any,
  parentObject?: any,
): Record<string, any> {
  let toObject: Record<string, any> = {};

  let fromModel = common.getValueByPath(fromObject, ['model']);
  if (fromModel !== undefined) {
    common.setValueByPath(
      toObject,
      ['_url', 'model'],
      t.tModel(apiClient, fromModel),
    );
  }

  let fromContents = common.getValueByPath(fromObject, ['contents']);
  if (fromContents !== undefined) {
    common.setValueByPath(
      toObject,
      ['contents'],
      t.tContents(
        apiClient,
        t.tContents(apiClient, fromContents)!.map((item: any) => {
          return contentToVertex(apiClient, item, toObject);
        }),
      ),
    );
  }

  let fromConfig = common.getValueByPath(fromObject, ['config']);
  if (fromConfig !== undefined) {
    common.setValueByPath(
      toObject,
      ['config'],
      countTokensConfigToVertex(apiClient, fromConfig, toObject),
    );
  }

  return toObject;
}

function computeTokensParametersToMldev(
  apiClient: ApiClient,
  fromObject: any,
  parentObject?: any,
): Record<string, any> {
  let toObject: Record<string, any> = {};

  let fromModel = common.getValueByPath(fromObject, ['model']);
  if (fromModel !== undefined) {
    common.setValueByPath(
      toObject,
      ['_url', 'model'],
      t.tModel(apiClient, fromModel),
    );
  }

  if (common.getValueByPath(fromObject, ['contents']) !== undefined) {
    throw new Error('contents parameter is not supported in Gemini API.');
  }

  let fromConfig = common.getValueByPath(fromObject, ['config']);
  if (fromConfig !== undefined) {
    common.setValueByPath(toObject, ['config'], fromConfig);
  }

  return toObject;
}

function computeTokensParametersToVertex(
  apiClient: ApiClient,
  fromObject: any,
  parentObject?: any,
): Record<string, any> {
  let toObject: Record<string, any> = {};

  let fromModel = common.getValueByPath(fromObject, ['model']);
  if (fromModel !== undefined) {
    common.setValueByPath(
      toObject,
      ['_url', 'model'],
      t.tModel(apiClient, fromModel),
    );
  }

  let fromContents = common.getValueByPath(fromObject, ['contents']);
  if (fromContents !== undefined) {
    common.setValueByPath(
      toObject,
      ['contents'],
      t.tContents(
        apiClient,
        t.tContents(apiClient, fromContents)!.map((item: any) => {
          return contentToVertex(apiClient, item, toObject);
        }),
      ),
    );
  }

  let fromConfig = common.getValueByPath(fromObject, ['config']);
  if (fromConfig !== undefined) {
    common.setValueByPath(toObject, ['config'], fromConfig);
  }

  return toObject;
}

function partFromMldev(
  apiClient: ApiClient,
  fromObject: any,
  parentObject?: any,
): Record<string, any> {
  let toObject: Record<string, any> = {};

  let fromThought = common.getValueByPath(fromObject, ['thought']);
  if (fromThought !== undefined) {
    common.setValueByPath(toObject, ['thought'], fromThought);
  }

  let fromCodeExecutionResult = common.getValueByPath(fromObject, [
    'codeExecutionResult',
  ]);
  if (fromCodeExecutionResult !== undefined) {
    common.setValueByPath(
      toObject,
      ['codeExecutionResult'],
      fromCodeExecutionResult,
    );
  }

  let fromExecutableCode = common.getValueByPath(fromObject, [
    'executableCode',
  ]);
  if (fromExecutableCode !== undefined) {
    common.setValueByPath(toObject, ['executableCode'], fromExecutableCode);
  }

  let fromFileData = common.getValueByPath(fromObject, ['fileData']);
  if (fromFileData !== undefined) {
    common.setValueByPath(toObject, ['fileData'], fromFileData);
  }

  let fromFunctionCall = common.getValueByPath(fromObject, ['functionCall']);
  if (fromFunctionCall !== undefined) {
    common.setValueByPath(toObject, ['functionCall'], fromFunctionCall);
  }

  let fromFunctionResponse = common.getValueByPath(fromObject, [
    'functionResponse',
  ]);
  if (fromFunctionResponse !== undefined) {
    common.setValueByPath(toObject, ['functionResponse'], fromFunctionResponse);
  }

  let fromInlineData = common.getValueByPath(fromObject, ['inlineData']);
  if (fromInlineData !== undefined) {
    common.setValueByPath(toObject, ['inlineData'], fromInlineData);
  }

  let fromText = common.getValueByPath(fromObject, ['text']);
  if (fromText !== undefined) {
    common.setValueByPath(toObject, ['text'], fromText);
  }

  return toObject;
}

function partFromVertex(
  apiClient: ApiClient,
  fromObject: any,
  parentObject?: any,
): Record<string, any> {
  let toObject: Record<string, any> = {};

  let fromVideoMetadata = common.getValueByPath(fromObject, ['videoMetadata']);
  if (fromVideoMetadata !== undefined) {
    common.setValueByPath(toObject, ['videoMetadata'], fromVideoMetadata);
  }

  let fromThought = common.getValueByPath(fromObject, ['thought']);
  if (fromThought !== undefined) {
    common.setValueByPath(toObject, ['thought'], fromThought);
  }

  let fromCodeExecutionResult = common.getValueByPath(fromObject, [
    'codeExecutionResult',
  ]);
  if (fromCodeExecutionResult !== undefined) {
    common.setValueByPath(
      toObject,
      ['codeExecutionResult'],
      fromCodeExecutionResult,
    );
  }

  let fromExecutableCode = common.getValueByPath(fromObject, [
    'executableCode',
  ]);
  if (fromExecutableCode !== undefined) {
    common.setValueByPath(toObject, ['executableCode'], fromExecutableCode);
  }

  let fromFileData = common.getValueByPath(fromObject, ['fileData']);
  if (fromFileData !== undefined) {
    common.setValueByPath(toObject, ['fileData'], fromFileData);
  }

  let fromFunctionCall = common.getValueByPath(fromObject, ['functionCall']);
  if (fromFunctionCall !== undefined) {
    common.setValueByPath(toObject, ['functionCall'], fromFunctionCall);
  }

  let fromFunctionResponse = common.getValueByPath(fromObject, [
    'functionResponse',
  ]);
  if (fromFunctionResponse !== undefined) {
    common.setValueByPath(toObject, ['functionResponse'], fromFunctionResponse);
  }

  let fromInlineData = common.getValueByPath(fromObject, ['inlineData']);
  if (fromInlineData !== undefined) {
    common.setValueByPath(toObject, ['inlineData'], fromInlineData);
  }

  let fromText = common.getValueByPath(fromObject, ['text']);
  if (fromText !== undefined) {
    common.setValueByPath(toObject, ['text'], fromText);
  }

  return toObject;
}

export function contentFromMldev(
  apiClient: ApiClient,
  fromObject: any,
  parentObject?: any,
): Record<string, any> {
  let toObject: Record<string, any> = {};

  let fromParts = common.getValueByPath(fromObject, ['parts']);
  if (fromParts !== undefined) {
    common.setValueByPath(
      toObject,
      ['parts'],
      fromParts!.map((item: any) => {
        return partFromMldev(apiClient, item, toObject);
      }),
    );
  }

  let fromRole = common.getValueByPath(fromObject, ['role']);
  if (fromRole !== undefined) {
    common.setValueByPath(toObject, ['role'], fromRole);
  }

  return toObject;
}

export function contentFromVertex(
  apiClient: ApiClient,
  fromObject: any,
  parentObject?: any,
): Record<string, any> {
  let toObject: Record<string, any> = {};

  let fromParts = common.getValueByPath(fromObject, ['parts']);
  if (fromParts !== undefined) {
    common.setValueByPath(
      toObject,
      ['parts'],
      fromParts!.map((item: any) => {
        return partFromVertex(apiClient, item, toObject);
      }),
    );
  }

  let fromRole = common.getValueByPath(fromObject, ['role']);
  if (fromRole !== undefined) {
    common.setValueByPath(toObject, ['role'], fromRole);
  }

  return toObject;
}

function citationMetadataFromMldev(
  apiClient: ApiClient,
  fromObject: any,
  parentObject?: any,
): Record<string, any> {
  let toObject: Record<string, any> = {};

  let fromCitations = common.getValueByPath(fromObject, ['citationSources']);
  if (fromCitations !== undefined) {
    common.setValueByPath(toObject, ['citations'], fromCitations);
  }

  return toObject;
}

function citationMetadataFromVertex(
  apiClient: ApiClient,
  fromObject: any,
  parentObject?: any,
): Record<string, any> {
  let toObject: Record<string, any> = {};

  let fromCitations = common.getValueByPath(fromObject, ['citations']);
  if (fromCitations !== undefined) {
    common.setValueByPath(toObject, ['citations'], fromCitations);
  }

  return toObject;
}

function candidateFromMldev(
  apiClient: ApiClient,
  fromObject: any,
  parentObject?: any,
): Record<string, any> {
  let toObject: Record<string, any> = {};

  let fromContent = common.getValueByPath(fromObject, ['content']);
  if (fromContent !== undefined) {
    common.setValueByPath(
      toObject,
      ['content'],
      contentFromMldev(apiClient, fromContent, toObject),
    );
  }

  let fromCitationMetadata = common.getValueByPath(fromObject, [
    'citationMetadata',
  ]);
  if (fromCitationMetadata !== undefined) {
    common.setValueByPath(
      toObject,
      ['citationMetadata'],
      citationMetadataFromMldev(apiClient, fromCitationMetadata, toObject),
    );
  }

  let fromTokenCount = common.getValueByPath(fromObject, ['tokenCount']);
  if (fromTokenCount !== undefined) {
    common.setValueByPath(toObject, ['tokenCount'], fromTokenCount);
  }

  let fromAvgLogprobs = common.getValueByPath(fromObject, ['avgLogprobs']);
  if (fromAvgLogprobs !== undefined) {
    common.setValueByPath(toObject, ['avgLogprobs'], fromAvgLogprobs);
  }

  let fromFinishReason = common.getValueByPath(fromObject, ['finishReason']);
  if (fromFinishReason !== undefined) {
    common.setValueByPath(toObject, ['finishReason'], fromFinishReason);
  }

  let fromGroundingMetadata = common.getValueByPath(fromObject, [
    'groundingMetadata',
  ]);
  if (fromGroundingMetadata !== undefined) {
    common.setValueByPath(
      toObject,
      ['groundingMetadata'],
      fromGroundingMetadata,
    );
  }

  let fromIndex = common.getValueByPath(fromObject, ['index']);
  if (fromIndex !== undefined) {
    common.setValueByPath(toObject, ['index'], fromIndex);
  }

  let fromLogprobsResult = common.getValueByPath(fromObject, [
    'logprobsResult',
  ]);
  if (fromLogprobsResult !== undefined) {
    common.setValueByPath(toObject, ['logprobsResult'], fromLogprobsResult);
  }

  let fromSafetyRatings = common.getValueByPath(fromObject, ['safetyRatings']);
  if (fromSafetyRatings !== undefined) {
    common.setValueByPath(toObject, ['safetyRatings'], fromSafetyRatings);
  }

  return toObject;
}

function candidateFromVertex(
  apiClient: ApiClient,
  fromObject: any,
  parentObject?: any,
): Record<string, any> {
  let toObject: Record<string, any> = {};

  let fromContent = common.getValueByPath(fromObject, ['content']);
  if (fromContent !== undefined) {
    common.setValueByPath(
      toObject,
      ['content'],
      contentFromVertex(apiClient, fromContent, toObject),
    );
  }

  let fromCitationMetadata = common.getValueByPath(fromObject, [
    'citationMetadata',
  ]);
  if (fromCitationMetadata !== undefined) {
    common.setValueByPath(
      toObject,
      ['citationMetadata'],
      citationMetadataFromVertex(apiClient, fromCitationMetadata, toObject),
    );
  }

  let fromFinishMessage = common.getValueByPath(fromObject, ['finishMessage']);
  if (fromFinishMessage !== undefined) {
    common.setValueByPath(toObject, ['finishMessage'], fromFinishMessage);
  }

  let fromAvgLogprobs = common.getValueByPath(fromObject, ['avgLogprobs']);
  if (fromAvgLogprobs !== undefined) {
    common.setValueByPath(toObject, ['avgLogprobs'], fromAvgLogprobs);
  }

  let fromFinishReason = common.getValueByPath(fromObject, ['finishReason']);
  if (fromFinishReason !== undefined) {
    common.setValueByPath(toObject, ['finishReason'], fromFinishReason);
  }

  let fromGroundingMetadata = common.getValueByPath(fromObject, [
    'groundingMetadata',
  ]);
  if (fromGroundingMetadata !== undefined) {
    common.setValueByPath(
      toObject,
      ['groundingMetadata'],
      fromGroundingMetadata,
    );
  }

  let fromIndex = common.getValueByPath(fromObject, ['index']);
  if (fromIndex !== undefined) {
    common.setValueByPath(toObject, ['index'], fromIndex);
  }

  let fromLogprobsResult = common.getValueByPath(fromObject, [
    'logprobsResult',
  ]);
  if (fromLogprobsResult !== undefined) {
    common.setValueByPath(toObject, ['logprobsResult'], fromLogprobsResult);
  }

  let fromSafetyRatings = common.getValueByPath(fromObject, ['safetyRatings']);
  if (fromSafetyRatings !== undefined) {
    common.setValueByPath(toObject, ['safetyRatings'], fromSafetyRatings);
  }

  return toObject;
}

function generateContentResponseFromMldev(
  apiClient: ApiClient,
  fromObject: any,
  parentObject?: any,
): Record<string, any> {
  let toObject: Record<string, any> = {};

  let fromCandidates = common.getValueByPath(fromObject, ['candidates']);
  if (fromCandidates !== undefined) {
    common.setValueByPath(
      toObject,
      ['candidates'],
      fromCandidates!.map((item: any) => {
        return candidateFromMldev(apiClient, item, toObject);
      }),
    );
  }

  let fromModelVersion = common.getValueByPath(fromObject, ['modelVersion']);
  if (fromModelVersion !== undefined) {
    common.setValueByPath(toObject, ['modelVersion'], fromModelVersion);
  }

  let fromPromptFeedback = common.getValueByPath(fromObject, [
    'promptFeedback',
  ]);
  if (fromPromptFeedback !== undefined) {
    common.setValueByPath(toObject, ['promptFeedback'], fromPromptFeedback);
  }

  let fromUsageMetadata = common.getValueByPath(fromObject, ['usageMetadata']);
  if (fromUsageMetadata !== undefined) {
    common.setValueByPath(toObject, ['usageMetadata'], fromUsageMetadata);
  }

  return toObject;
}

function generateContentResponseFromVertex(
  apiClient: ApiClient,
  fromObject: any,
  parentObject?: any,
): Record<string, any> {
  let toObject: Record<string, any> = {};

  let fromCandidates = common.getValueByPath(fromObject, ['candidates']);
  if (fromCandidates !== undefined) {
    common.setValueByPath(
      toObject,
      ['candidates'],
      fromCandidates!.map((item: any) => {
        return candidateFromVertex(apiClient, item, toObject);
      }),
    );
  }

  let fromModelVersion = common.getValueByPath(fromObject, ['modelVersion']);
  if (fromModelVersion !== undefined) {
    common.setValueByPath(toObject, ['modelVersion'], fromModelVersion);
  }

  let fromPromptFeedback = common.getValueByPath(fromObject, [
    'promptFeedback',
  ]);
  if (fromPromptFeedback !== undefined) {
    common.setValueByPath(toObject, ['promptFeedback'], fromPromptFeedback);
  }

  let fromUsageMetadata = common.getValueByPath(fromObject, ['usageMetadata']);
  if (fromUsageMetadata !== undefined) {
    common.setValueByPath(toObject, ['usageMetadata'], fromUsageMetadata);
  }

  return toObject;
}

function contentEmbeddingStatisticsFromMldev(
  apiClient: ApiClient,
  fromObject: any,
  parentObject?: any,
): Record<string, any> {
  let toObject: Record<string, any> = {};

  return toObject;
}

function contentEmbeddingStatisticsFromVertex(
  apiClient: ApiClient,
  fromObject: any,
  parentObject?: any,
): Record<string, any> {
  let toObject: Record<string, any> = {};

  let fromTruncated = common.getValueByPath(fromObject, ['truncated']);
  if (fromTruncated !== undefined) {
    common.setValueByPath(toObject, ['truncated'], fromTruncated);
  }

  let fromTokenCount = common.getValueByPath(fromObject, ['token_count']);
  if (fromTokenCount !== undefined) {
    common.setValueByPath(toObject, ['tokenCount'], fromTokenCount);
  }

  return toObject;
}

function contentEmbeddingFromMldev(
  apiClient: ApiClient,
  fromObject: any,
  parentObject?: any,
): Record<string, any> {
  let toObject: Record<string, any> = {};

  let fromValues = common.getValueByPath(fromObject, ['values']);
  if (fromValues !== undefined) {
    common.setValueByPath(toObject, ['values'], fromValues);
  }

  return toObject;
}

function contentEmbeddingFromVertex(
  apiClient: ApiClient,
  fromObject: any,
  parentObject?: any,
): Record<string, any> {
  let toObject: Record<string, any> = {};

  let fromValues = common.getValueByPath(fromObject, ['values']);
  if (fromValues !== undefined) {
    common.setValueByPath(toObject, ['values'], fromValues);
  }

  let fromStatistics = common.getValueByPath(fromObject, ['statistics']);
  if (fromStatistics !== undefined) {
    common.setValueByPath(
      toObject,
      ['statistics'],
      contentEmbeddingStatisticsFromVertex(apiClient, fromStatistics, toObject),
    );
  }

  return toObject;
}

function embedContentMetadataFromMldev(
  apiClient: ApiClient,
  fromObject: any,
  parentObject?: any,
): Record<string, any> {
  let toObject: Record<string, any> = {};

  return toObject;
}

function embedContentMetadataFromVertex(
  apiClient: ApiClient,
  fromObject: any,
  parentObject?: any,
): Record<string, any> {
  let toObject: Record<string, any> = {};

  let fromBillableCharacterCount = common.getValueByPath(fromObject, [
    'billableCharacterCount',
  ]);
  if (fromBillableCharacterCount !== undefined) {
    common.setValueByPath(
      toObject,
      ['billableCharacterCount'],
      fromBillableCharacterCount,
    );
  }

  return toObject;
}

function embedContentResponseFromMldev(
  apiClient: ApiClient,
  fromObject: any,
  parentObject?: any,
): Record<string, any> {
  let toObject: Record<string, any> = {};

  let fromEmbeddings = common.getValueByPath(fromObject, ['embeddings']);
  if (fromEmbeddings !== undefined) {
    common.setValueByPath(
      toObject,
      ['embeddings'],
      fromEmbeddings!.map((item: any) => {
        return contentEmbeddingFromMldev(apiClient, item, toObject);
      }),
    );
  }

  let fromMetadata = common.getValueByPath(fromObject, ['metadata']);
  if (fromMetadata !== undefined) {
    common.setValueByPath(
      toObject,
      ['metadata'],
      embedContentMetadataFromMldev(apiClient, fromMetadata, toObject),
    );
  }

  return toObject;
}

function embedContentResponseFromVertex(
  apiClient: ApiClient,
  fromObject: any,
  parentObject?: any,
): Record<string, any> {
  let toObject: Record<string, any> = {};

  let fromEmbeddings = common.getValueByPath(fromObject, [
    'predictions[]',
    'embeddings',
  ]);
  if (fromEmbeddings !== undefined) {
    common.setValueByPath(
      toObject,
      ['embeddings'],
      fromEmbeddings!.map((item: any) => {
        return contentEmbeddingFromVertex(apiClient, item, toObject);
      }),
    );
  }

  let fromMetadata = common.getValueByPath(fromObject, ['metadata']);
  if (fromMetadata !== undefined) {
    common.setValueByPath(
      toObject,
      ['metadata'],
      embedContentMetadataFromVertex(apiClient, fromMetadata, toObject),
    );
  }

  return toObject;
}

function imageFromMldev(
  apiClient: ApiClient,
  fromObject: any,
  parentObject?: any,
): Record<string, any> {
  let toObject: Record<string, any> = {};

  let fromImageBytes = common.getValueByPath(fromObject, [
    'bytesBase64Encoded',
  ]);
  if (fromImageBytes !== undefined) {
    common.setValueByPath(
      toObject,
      ['imageBytes'],
      t.tBytes(apiClient, fromImageBytes),
    );
  }

  let fromMimeType = common.getValueByPath(fromObject, ['mimeType']);
  if (fromMimeType !== undefined) {
    common.setValueByPath(toObject, ['mimeType'], fromMimeType);
  }

  return toObject;
}

function imageFromVertex(
  apiClient: ApiClient,
  fromObject: any,
  parentObject?: any,
): Record<string, any> {
  let toObject: Record<string, any> = {};

  let fromGcsUri = common.getValueByPath(fromObject, ['gcsUri']);
  if (fromGcsUri !== undefined) {
    common.setValueByPath(toObject, ['gcsUri'], fromGcsUri);
  }

  let fromImageBytes = common.getValueByPath(fromObject, [
    'bytesBase64Encoded',
  ]);
  if (fromImageBytes !== undefined) {
    common.setValueByPath(
      toObject,
      ['imageBytes'],
      t.tBytes(apiClient, fromImageBytes),
    );
  }

  let fromMimeType = common.getValueByPath(fromObject, ['mimeType']);
  if (fromMimeType !== undefined) {
    common.setValueByPath(toObject, ['mimeType'], fromMimeType);
  }

  return toObject;
}

function generatedImageFromMldev(
  apiClient: ApiClient,
  fromObject: any,
  parentObject?: any,
): Record<string, any> {
  let toObject: Record<string, any> = {};

  let fromImage = common.getValueByPath(fromObject, ['_self']);
  if (fromImage !== undefined) {
    common.setValueByPath(
      toObject,
      ['image'],
      imageFromMldev(apiClient, fromImage, toObject),
    );
  }

  let fromRaiFilteredReason = common.getValueByPath(fromObject, [
    'raiFilteredReason',
  ]);
  if (fromRaiFilteredReason !== undefined) {
    common.setValueByPath(
      toObject,
      ['raiFilteredReason'],
      fromRaiFilteredReason,
    );
  }

  return toObject;
}

function generatedImageFromVertex(
  apiClient: ApiClient,
  fromObject: any,
  parentObject?: any,
): Record<string, any> {
  let toObject: Record<string, any> = {};

  let fromImage = common.getValueByPath(fromObject, ['_self']);
  if (fromImage !== undefined) {
    common.setValueByPath(
      toObject,
      ['image'],
      imageFromVertex(apiClient, fromImage, toObject),
    );
  }

  let fromRaiFilteredReason = common.getValueByPath(fromObject, [
    'raiFilteredReason',
  ]);
  if (fromRaiFilteredReason !== undefined) {
    common.setValueByPath(
      toObject,
      ['raiFilteredReason'],
      fromRaiFilteredReason,
    );
  }

  return toObject;
}

function generateImagesResponseFromMldev(
  apiClient: ApiClient,
  fromObject: any,
  parentObject?: any,
): Record<string, any> {
  let toObject: Record<string, any> = {};

  let fromGeneratedImages = common.getValueByPath(fromObject, ['predictions']);
  if (fromGeneratedImages !== undefined) {
    common.setValueByPath(
      toObject,
      ['generatedImages'],
      fromGeneratedImages!.map((item: any) => {
        return generatedImageFromMldev(apiClient, item, toObject);
      }),
    );
  }

  return toObject;
}

function generateImagesResponseFromVertex(
  apiClient: ApiClient,
  fromObject: any,
  parentObject?: any,
): Record<string, any> {
  let toObject: Record<string, any> = {};

  let fromGeneratedImages = common.getValueByPath(fromObject, ['predictions']);
  if (fromGeneratedImages !== undefined) {
    common.setValueByPath(
      toObject,
      ['generatedImages'],
      fromGeneratedImages!.map((item: any) => {
        return generatedImageFromVertex(apiClient, item, toObject);
      }),
    );
  }

  return toObject;
}

function countTokensResponseFromMldev(
  apiClient: ApiClient,
  fromObject: any,
  parentObject?: any,
): Record<string, any> {
  let toObject: Record<string, any> = {};

  let fromTotalTokens = common.getValueByPath(fromObject, ['totalTokens']);
  if (fromTotalTokens !== undefined) {
    common.setValueByPath(toObject, ['totalTokens'], fromTotalTokens);
  }

  let fromCachedContentTokenCount = common.getValueByPath(fromObject, [
    'cachedContentTokenCount',
  ]);
  if (fromCachedContentTokenCount !== undefined) {
    common.setValueByPath(
      toObject,
      ['cachedContentTokenCount'],
      fromCachedContentTokenCount,
    );
  }

  return toObject;
}

function countTokensResponseFromVertex(
  apiClient: ApiClient,
  fromObject: any,
  parentObject?: any,
): Record<string, any> {
  let toObject: Record<string, any> = {};

  let fromTotalTokens = common.getValueByPath(fromObject, ['totalTokens']);
  if (fromTotalTokens !== undefined) {
    common.setValueByPath(toObject, ['totalTokens'], fromTotalTokens);
  }

  return toObject;
}

function computeTokensResponseFromMldev(
  apiClient: ApiClient,
  fromObject: any,
  parentObject?: any,
): Record<string, any> {
  let toObject: Record<string, any> = {};

  let fromTokensInfo = common.getValueByPath(fromObject, ['tokensInfo']);
  if (fromTokensInfo !== undefined) {
    common.setValueByPath(toObject, ['tokensInfo'], fromTokensInfo);
  }

  return toObject;
}

function computeTokensResponseFromVertex(
  apiClient: ApiClient,
  fromObject: any,
  parentObject?: any,
): Record<string, any> {
  let toObject: Record<string, any> = {};

  let fromTokensInfo = common.getValueByPath(fromObject, ['tokensInfo']);
  if (fromTokensInfo !== undefined) {
    common.setValueByPath(toObject, ['tokensInfo'], fromTokensInfo);
  }

  return toObject;
}

export class Models extends BaseModule {
  constructor(private readonly apiClient: ApiClient) {
    super();
  }

  private async _generateContent(
    model: string,
    contents: types.ContentListUnion,
    config?: types.GenerateContentConfig,
  ): Promise<types.GenerateContentResponse> {
    let response: Promise<types.GenerateContentResponse>;
    let path: string = '';
    let body: Record<string, any> = {};
    let kwargs: Record<string, any> = {};
    kwargs['model'] = model;
    kwargs['contents'] = contents;
    kwargs['config'] = config;
    if (this.apiClient.isVertexAI()) {
      body = generateContentParametersToVertex(this.apiClient, kwargs);
      path = common.formatMap('{model}:generateContent', body['_url']);
      delete body['config']; // TODO: Remove this hack for removing config.
      response = this.apiClient.post(path, body, types.GenerateContentResponse);

      return response.then((apiResponse) => {
        const resp = generateContentResponseFromVertex(
          this.apiClient,
          apiResponse,
        );
        Object.setPrototypeOf(resp, types.GenerateContentResponse.prototype);
        return resp as types.GenerateContentResponse;
      });
    } else {
      body = generateContentParametersToMldev(this.apiClient, kwargs);
      path = common.formatMap('{model}:generateContent', body['_url']);
      delete body['config']; // TODO: Remove this hack for removing config.
      response = this.apiClient.post(path, body, types.GenerateContentResponse);

      return response.then((apiResponse) => {
        const resp = generateContentResponseFromMldev(
          this.apiClient,
          apiResponse,
        );
        Object.setPrototypeOf(resp, types.GenerateContentResponse.prototype);
        return resp as types.GenerateContentResponse;
      });
    }
  }

  async generateContentStream(
    model: string,
    contents: types.ContentListUnion,
    config?: types.GenerateContentConfig,
  ): Promise<AsyncGenerator<types.GenerateContentResponse>> {
    let response: Promise<AsyncGenerator<types.GenerateContentResponse>>;
    let path: string = '';
    let body: Record<string, any> = {};
    let kwargs: Record<string, any> = {};
    kwargs['model'] = model;
    kwargs['contents'] = contents;
    kwargs['config'] = config;
    if (this.apiClient.isVertexAI()) {
      body = generateContentParametersToVertex(this.apiClient, kwargs);
      path = common.formatMap(
        '{model}:streamGenerateContent?alt=sse',
        body['_url'],
      );
      delete body['config']; // TODO: Remove this hack for removing config.
      response = this.apiClient.postStream(
        path,
        body,
        types.GenerateContentResponse,
      );

      let apiClient = this.apiClient;
      return response.then(async function* (apiResponse: any) {
        for await (const chunk of apiResponse) {
          const resp = generateContentResponseFromVertex(apiClient, chunk);
          Object.setPrototypeOf(resp, types.GenerateContentResponse.prototype);
          yield resp as types.GenerateContentResponse;
        }
      });
    } else {
      body = generateContentParametersToMldev(this.apiClient, kwargs);
      path = common.formatMap(
        '{model}:streamGenerateContent?alt=sse',
        body['_url'],
      );
      delete body['config']; // TODO: Remove this hack for removing config.
      response = this.apiClient.postStream(
        path,
        body,
        types.GenerateContentResponse,
      );

      let apiClient = this.apiClient;
      return response.then(async function* (apiResponse: any) {
        for await (const chunk of apiResponse) {
          const resp = generateContentResponseFromMldev(apiClient, chunk);
          Object.setPrototypeOf(resp, types.GenerateContentResponse.prototype);
          yield resp as types.GenerateContentResponse;
        }
      });
    }
  }

  async embedContent(
    model: string,
    contents: types.ContentListUnion,
    config?: types.EmbedContentConfig,
  ): Promise<types.EmbedContentResponse> {
    let response: Promise<types.EmbedContentResponse>;
    let path: string = '';
    let body: Record<string, any> = {};
    let kwargs: Record<string, any> = {};
    kwargs['model'] = model;
    kwargs['contents'] = contents;
    kwargs['config'] = config;
    if (this.apiClient.isVertexAI()) {
      body = embedContentParametersToVertex(this.apiClient, kwargs);
      path = common.formatMap('{model}:predict', body['_url']);
      delete body['config']; // TODO: Remove this hack for removing config.
      response = this.apiClient.post(path, body, types.EmbedContentResponse);

      return response.then((apiResponse) => {
        const resp = embedContentResponseFromVertex(
          this.apiClient,
          apiResponse,
        );
        Object.setPrototypeOf(resp, types.EmbedContentResponse.prototype);
        return resp as types.EmbedContentResponse;
      });
    } else {
      body = embedContentParametersToMldev(this.apiClient, kwargs);
      path = common.formatMap('{model}:batchEmbedContents', body['_url']);
      delete body['config']; // TODO: Remove this hack for removing config.
      response = this.apiClient.post(path, body, types.EmbedContentResponse);

      return response.then((apiResponse) => {
        const resp = embedContentResponseFromMldev(this.apiClient, apiResponse);
        Object.setPrototypeOf(resp, types.EmbedContentResponse.prototype);
        return resp as types.EmbedContentResponse;
      });
    }
  }

  async generateImages(
    model: string,
    prompt: string,
    config?: types.GenerateImagesConfig,
  ): Promise<types.GenerateImagesResponse> {
    let response: Promise<types.GenerateImagesResponse>;
    let path: string = '';
    let body: Record<string, any> = {};
    let kwargs: Record<string, any> = {};
    kwargs['model'] = model;
    kwargs['prompt'] = prompt;
    kwargs['config'] = config;
    if (this.apiClient.isVertexAI()) {
      body = generateImagesParametersToVertex(this.apiClient, kwargs);
      path = common.formatMap('{model}:predict', body['_url']);
      delete body['config']; // TODO: Remove this hack for removing config.
      response = this.apiClient.post(path, body, types.GenerateImagesResponse);

      return response.then((apiResponse) => {
        const resp = generateImagesResponseFromVertex(
          this.apiClient,
          apiResponse,
        );
        Object.setPrototypeOf(resp, types.GenerateImagesResponse.prototype);
        return resp as types.GenerateImagesResponse;
      });
    } else {
      body = generateImagesParametersToMldev(this.apiClient, kwargs);
      path = common.formatMap('{model}:predict', body['_url']);
      delete body['config']; // TODO: Remove this hack for removing config.
      response = this.apiClient.post(path, body, types.GenerateImagesResponse);

      return response.then((apiResponse) => {
        const resp = generateImagesResponseFromMldev(
          this.apiClient,
          apiResponse,
        );
        Object.setPrototypeOf(resp, types.GenerateImagesResponse.prototype);
        return resp as types.GenerateImagesResponse;
      });
    }
  }

  /**
   * Counts the number of tokens in the given contents.
   *
   * @param model - The model to use for counting tokens.
   * @param contents - The contents to count tokens for.
   *                                      Multimodal input is supported for
   *                                      Gemini models.
   * @param [config] - The config for counting tokens.
   * @return The response from the API.
   *
   * @example
   * ```ts
   * const response = await client.models.countTokens(
   *  'gemini-1.5-flash',
   *  'The quick brown fox jumps over the lazy dog.'
   * );
   * console.log(response);
   * ```
   */
  async countTokens(
    model: string,
    contents: types.ContentListUnion,
    config?: types.CountTokensConfig,
  ): Promise<types.CountTokensResponse> {
    let response: Promise<types.CountTokensResponse>;
    let path: string = '';
    let body: Record<string, any> = {};
    let kwargs: Record<string, any> = {};
    kwargs['model'] = model;
    kwargs['contents'] = contents;
    kwargs['config'] = config;
    if (this.apiClient.isVertexAI()) {
      body = countTokensParametersToVertex(this.apiClient, kwargs);
      path = common.formatMap('{model}:countTokens', body['_url']);
      delete body['config']; // TODO: Remove this hack for removing config.
      response = this.apiClient.post(path, body, types.CountTokensResponse);

      return response.then((apiResponse) => {
        const resp = countTokensResponseFromVertex(this.apiClient, apiResponse);
        Object.setPrototypeOf(resp, types.CountTokensResponse.prototype);
        return resp as types.CountTokensResponse;
      });
    } else {
      body = countTokensParametersToMldev(this.apiClient, kwargs);
      path = common.formatMap('{model}:countTokens', body['_url']);
      delete body['config']; // TODO: Remove this hack for removing config.
      response = this.apiClient.post(path, body, types.CountTokensResponse);

      return response.then((apiResponse) => {
        const resp = countTokensResponseFromMldev(this.apiClient, apiResponse);
        Object.setPrototypeOf(resp, types.CountTokensResponse.prototype);
        return resp as types.CountTokensResponse;
      });
    }
  }

  async computeTokens(
    model: string,
    contents: types.ContentListUnion,
    config?: types.ComputeTokensConfig,
  ): Promise<types.ComputeTokensResponse> {
    let response: Promise<types.ComputeTokensResponse>;
    let path: string = '';
    let body: Record<string, any> = {};
    let kwargs: Record<string, any> = {};
    kwargs['model'] = model;
    kwargs['contents'] = contents;
    kwargs['config'] = config;
    if (this.apiClient.isVertexAI()) {
      body = computeTokensParametersToVertex(this.apiClient, kwargs);
      path = common.formatMap('{model}:computeTokens', body['_url']);
      delete body['config']; // TODO: Remove this hack for removing config.
      response = this.apiClient.post(path, body, types.ComputeTokensResponse);

      return response.then((apiResponse) => {
        const resp = computeTokensResponseFromVertex(
          this.apiClient,
          apiResponse,
        );
        Object.setPrototypeOf(resp, types.ComputeTokensResponse.prototype);
        return resp as types.ComputeTokensResponse;
      });
    } else {
      body = computeTokensParametersToMldev(this.apiClient, kwargs);
      path = common.formatMap('None', body['_url']);
      delete body['config']; // TODO: Remove this hack for removing config.
      response = this.apiClient.post(path, body, types.ComputeTokensResponse);

      return response.then((apiResponse) => {
        const resp = computeTokensResponseFromMldev(
          this.apiClient,
          apiResponse,
        );
        Object.setPrototypeOf(resp, types.ComputeTokensResponse.prototype);
        return resp as types.ComputeTokensResponse;
      });
    }
  }

  generateContent = (
    model: string,
    contents: types.ContentListUnion,
    config?: types.GenerateContentConfig,
  ): Promise<types.GenerateContentResponse> => {
    return this._generateContent(model, contents, config);
  };
}
